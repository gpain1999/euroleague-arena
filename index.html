<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Basket Arena - Duel Central</title>

  <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.3/dist/confetti.browser.min.js"></script>

  <style>
    @import url('https://fonts.googleapis.com/css2?family=Barlow+Condensed:ital,wght@0,400;0,700;0,900;1,900&family=Barlow:wght@400;600;700&display=swap');

    :root {
      --orange: #f97316;
      --gold: #eab308;
      --bg: #020617;
    }

    * { box-sizing: border-box; }
    body { font-family: 'Barlow', sans-serif; background-color: var(--bg); color: #f8fafc; margin: 0; }

    .font-display { font-family: 'Barlow Condensed', sans-serif; }

    .scrollbar-hide::-webkit-scrollbar { display: none; }
    .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }

    @keyframes roll { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    .animate-roll { animation: roll 1s linear infinite; }

    @keyframes popStat {
      0% { transform: scale(0.5) translateY(20px); opacity: 0; }
      50% { transform: scale(1.1) translateY(-5px); opacity: 1; }
      100% { transform: scale(1) translateY(0); opacity: 1; }
    }
    .animate-pop-stat { animation: popStat 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275) forwards; }

    @keyframes fadeInUp {
      from { opacity: 0; transform: translateY(30px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .fade-in-up { animation: fadeInUp 0.6s ease forwards; }
    .fade-in-up-1 { animation: fadeInUp 0.6s ease 0.1s both; }
    .fade-in-up-2 { animation: fadeInUp 0.6s ease 0.2s both; }
    .fade-in-up-3 { animation: fadeInUp 0.6s ease 0.3s both; }
    .fade-in-up-4 { animation: fadeInUp 0.6s ease 0.4s both; }

    @keyframes pulse-glow {
      0%, 100% { box-shadow: 0 0 20px rgba(249,115,22,0.3); }
      50% { box-shadow: 0 0 40px rgba(249,115,22,0.6); }
    }
    .pulse-glow { animation: pulse-glow 2s ease-in-out infinite; }

    .card-shadow { box-shadow: 0 10px 25px -5px rgba(0,0,0,0.5); }

    .drop-zone {
      border: 2px dashed #334155;
      border-radius: 9999px;
      width: 0.75rem;
      height: 4rem;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      flex-shrink: 0;
      transition: all 0.2s;
    }
    .drop-zone:hover { border-color: #3b82f6; background: rgba(59,130,246,0.1); }

    .team-zone-transition { transition: all 0.5s cubic-bezier(0.4,0,0.2,1); }
    .glow-gold { box-shadow: 0 0 40px -10px rgba(234,179,8,0.2); }
    .glow-silver { box-shadow: 0 0 40px -10px rgba(148,163,184,0.2); }

    .home-bg {
      background: radial-gradient(ellipse at 30% 20%, rgba(249,115,22,0.15) 0%, transparent 50%),
                  radial-gradient(ellipse at 70% 80%, rgba(234,179,8,0.1) 0%, transparent 50%),
                  #020617;
    }

    .home-btn {
      position: relative;
      overflow: hidden;
      transition: all 0.3s ease;
    }
    .home-btn::before {
      content: '';
      position: absolute;
      top: 0; left: -100%;
      width: 100%; height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
      transition: left 0.4s ease;
    }
    .home-btn:hover::before { left: 100%; }
    .home-btn:hover { transform: translateY(-2px); }

    .rule-section {
      border-left: 3px solid;
      padding-left: 1rem;
      margin-bottom: 1.5rem;
    }

    .team-card-btn {
      transition: all 0.3s ease;
      position: relative;
      overflow: hidden;
    }
    .team-card-btn:hover { transform: translateY(-4px); }
    .team-card-btn::after {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(135deg, rgba(255,255,255,0.05) 0%, transparent 100%);
      opacity: 0;
      transition: opacity 0.3s;
    }
    .team-card-btn:hover::after { opacity: 1; }

    /* ====== DRAFT STYLES ====== */
    @keyframes draftCardIn {
      from { opacity: 0; transform: translateY(-40px) scale(0.85) rotateX(15deg); }
      to   { opacity: 1; transform: translateY(0)    scale(1)    rotateX(0deg);  }
    }
    .draft-card-in { animation: draftCardIn 0.45s cubic-bezier(0.34,1.56,0.64,1) both; }
    .draft-card-in-1 { animation: draftCardIn 0.45s 0.05s cubic-bezier(0.34,1.56,0.64,1) both; }
    .draft-card-in-2 { animation: draftCardIn 0.45s 0.12s cubic-bezier(0.34,1.56,0.64,1) both; }
    .draft-card-in-3 { animation: draftCardIn 0.45s 0.19s cubic-bezier(0.34,1.56,0.64,1) both; }

    @keyframes draftCardPick {
      0%   { transform: scale(1); }
      30%  { transform: scale(1.12); box-shadow: 0 0 40px rgba(249,115,22,0.7); }
      100% { transform: scale(0) translateY(-60px); opacity: 0; }
    }
    .draft-card-pick { animation: draftCardPick 0.5s ease forwards; }

    @keyframes picked-bounce {
      0%   { transform: scale(0.5); opacity: 0; }
      60%  { transform: scale(1.08); }
      100% { transform: scale(1); opacity: 1; }
    }
    .picked-bounce { animation: picked-bounce 0.4s cubic-bezier(0.34,1.56,0.64,1) both; }

    @keyframes ai-thinking {
      0%, 100% { opacity: 0.4; }
      50% { opacity: 1; }
    }
    .ai-thinking { animation: ai-thinking 0.7s ease-in-out infinite; }

    .draft-pool-card {
      transition: transform 0.25s ease, box-shadow 0.25s ease;
      cursor: pointer;
      perspective: 600px;
    }
    .draft-pool-card:hover {
      transform: translateY(-8px) scale(1.03);
      box-shadow: 0 20px 50px rgba(249,115,22,0.35);
    }
    .draft-pool-card.disabled {
      cursor: not-allowed;
      filter: brightness(0.5) saturate(0.4);
      pointer-events: none;
    }

    .serpentin-dot {
      width: 8px; height: 8px;
      border-radius: 50%;
      display: inline-block;
      margin: 0 2px;
    }

    @keyframes glow-pulse {
      0%, 100% { box-shadow: 0 0 12px rgba(249,115,22,0.4); }
      50% { box-shadow: 0 0 30px rgba(249,115,22,0.8); }
    }
    .active-turn-glow { animation: glow-pulse 1.2s ease-in-out infinite; }

    @keyframes slideRight {
      from { transform: translateX(-20px); opacity: 0; }
      to { transform: translateX(0); opacity: 1; }
    }
    .slide-right { animation: slideRight 0.3s ease both; }

    .draft-bg {
      background:
        radial-gradient(ellipse at 15% 50%, rgba(249,115,22,0.08) 0%, transparent 45%),
        radial-gradient(ellipse at 85% 20%, rgba(234,179,8,0.06) 0%, transparent 40%),
        radial-gradient(ellipse at 50% 80%, rgba(139,92,246,0.06) 0%, transparent 40%),
        #020617;
    }

    .picked-card-slot {
      border: 1.5px dashed #1e293b;
      border-radius: 12px;
      background: rgba(15,23,42,0.6);
      transition: all 0.3s;
    }
    .picked-card-slot.filled { border-color: transparent; background: transparent; }
  </style>
</head>

<body>
  <div id="root"></div>

  <script type="text/babel">
    const Icons = {
      Trophy: ({ size = 24 }) => (
        <svg width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/>
          <path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/>
          <path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/>
        </svg>
      ),
      Basketball: ({ className, size = 48 }) => (
        <svg className={className} width={size} height={size} viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <circle cx="12" cy="12" r="10"/><path d="M3.5 12h17"/><path d="M12 3.5v17"/>
          <path d="M5 5a12 12 0 0 1 14 14"/><path d="M19 5a12 12 0 0 0-14 14"/>
        </svg>
      ),
      History: () => (
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/><path d="m12 7 0 5 3 3"/>
        </svg>
      ),
      UserPlus: () => (
        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/>
          <line x1="19" x2="19" y1="8" y2="14"/><line x1="22" x2="16" y1="11" y2="11"/>
        </svg>
      ),
      Plus: () => (
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <line x1="12" y1="5" x2="12" y2="19"/><line x1="5" y1="12" x2="19" y2="12"/>
        </svg>
      ),
      Book: () => (
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <path d="M4 19.5v-15A2.5 2.5 0 0 1 6.5 2H20v20H6.5a2.5 2.5 0 0 1 0-5H20"/>
        </svg>
      ),
      Cards: () => (
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <rect width="16" height="20" x="2" y="2" rx="2" ry="2"/><path d="M7 2v20"/><path d="M17 2v20"/>
          <path d="M2 12h20"/><path d="M2 7h5"/><path d="M2 17h5"/>
        </svg>
      ),
      Play: () => (
        <svg width="24" height="24" viewBox="0 0 24 24" fill="currentColor">
          <polygon points="5 3 19 12 5 21 5 3"/>
        </svg>
      ),
      ArrowLeft: () => (
        <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round">
          <path d="m12 19-7-7 7-7"/><path d="M19 12H5"/>
        </svg>
      ),
      ChevronRight: () => (
        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2.5" strokeLinecap="round" strokeLinejoin="round">
          <path d="m9 18 6-6-6-6"/>
        </svg>
      ),
      Shuffle: () => (
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <polyline points="16 3 21 3 21 8"/><line x1="4" x2="21" y1="20" y2="3"/>
          <polyline points="21 16 21 21 16 21"/><line x1="15" x2="21" y1="15" y2="21"/>
          <line x1="4" x2="9" y1="4" y2="9"/>
        </svg>
      ),
      Draft: () => (
        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round">
          <path d="M8 3H5a2 2 0 0 0-2 2v3"/><path d="M21 8V5a2 2 0 0 0-2-2h-3"/>
          <path d="M3 16v3a2 2 0 0 0 2 2h3"/><path d="M16 21h3a2 2 0 0 0 2-2v-3"/>
          <circle cx="12" cy="12" r="3"/>
        </svg>
      ),
    };

    const BasketLogo = ({ size = 36, className = "" }) => {
      const [error, setError] = React.useState(false);
      if (error) return <Icons.Basketball size={size} className={className} />;
      return (
        <img src="euroleague_little.png" alt="Euroleague" width={size} height={size}
          className={className} onError={() => setError(true)} />
      );
    };

    const GAME_STATES = {
      LOADING: 'LOADING', HOME: 'HOME', PREGAME: 'PREGAME', KICKOFF: 'KICKOFF',
      PLAYING: 'PLAYING', GAMEOVER: 'GAMEOVER'
    };
    const PHASES = {
      IDLE: 'IDLE', ROLLING: 'ROLLING', CHOOSING_TARGET: 'CHOOSING_TARGET',
      DUEL: 'DUEL', REPLACING_DEF: 'REPLACING_DEF', PLACING_REPLACEMENT: 'PLACING_REPLACEMENT',
      ATK_SUB_DECISION: 'ATK_SUB_DECISION', REMOVING_ATK: 'REMOVING_ATK'
    };
    const POSTES = ['S', 'M', 'L'];
    const AUTO_CSV_URL = 'data/players.csv';
    const DRAFT_PICKS_PER_TEAM = 9; // 3S + 3M + 3L

    const { useState, useEffect, useCallback, useRef } = React;

    const parsePlayersCsv = (csvText) => {
      const lines = csvText.trim().split(/\r?\n/);
      if (!lines.length) return [];
      const headers = lines[0].split(';').map(h => h.trim());
      const seenPlayerIds = new Set();
      return lines.slice(1).map(line => {
        const values = line.split(';');
        const obj = {};
        headers.forEach((h, i) => {
          let val = values[i] ? values[i].trim() : "";
          if (val && !isNaN(val.replace(',', '.'))) val = parseFloat(val.replace(',', '.'));
          obj[h] = val;
        });
        return obj;
      }).filter(p => {
        if (!p.NAME || !p.PLAYER_ID) return false;
        const pid = String(p.PLAYER_ID);
        if (seenPlayerIds.has(pid)) return false;
        seenPlayerIds.add(pid);
        return true;
      });
    };

    // ==============================
    // SYNERGY
    // ==============================
    const getTeamName = (p) => String(p?.TEAM_y || p?.TEAM_x || '').trim();
    const computeSynergyTeams = (lineup) => {
      const counts = {};
      (lineup || []).forEach(p => { const t = getTeamName(p); if (!t) return; counts[t] = (counts[t] || 0) + 1; });
      return new Set(Object.entries(counts).filter(([, c]) => c >= 2).map(([t]) => t));
    };
    const effectiveOFF = (p, synergyTeams) => {
      const t = getTeamName(p); const base = Number(p?.OFF ?? 0);
      return (t && synergyTeams?.has(t)) ? base + 0.5 : base;
    };
    const effectiveDEF = (p, synergyTeams) => {
      const t = getTeamName(p); const base = Number(p?.DEF ?? 0);
      return (t && synergyTeams?.has(t)) ? base + 0.5 : base;
    };

    // ==============================
    // AI HELPERS
    // ==============================
    const clamp = (x, a, b) => Math.max(a, Math.min(b, x));
    const probScore = (atkPlayer, atkLineup, defPlayer, defLineup) => {
      if (!atkPlayer || !defPlayer) return 0.05;
      const atkSyn = computeSynergyTeams(atkLineup); const defSyn = computeSynergyTeams(defLineup);
      return clamp(0.5 + (effectiveOFF(atkPlayer, atkSyn) - effectiveDEF(defPlayer, defSyn)) / 18, 0.05, 0.95);
    };
    const expectedAttackEV = (atkLineup, defLineup) => {
      const probs = atkLineup.map((p, i) => probScore(p, atkLineup, defLineup[i], defLineup));
      return (probs.reduce((a, b) => a + b, 0) / 6) + (Math.max(...probs) / 6);
    };
    const expectedConcedeEV = (myLineup, oppLineup) => expectedAttackEV(oppLineup, myLineup);
    const isValidLineup = (lu) => {
      if (!lu || lu.length !== 5) return false;
      const cnt = { S: 0, M: 0, L: 0 };
      for (const p of lu) cnt[p.Poste]++;
      if (!(cnt.S && cnt.M && cnt.L)) return false;
      if (cnt.S > 2 || cnt.M > 2 || cnt.L > 2) return false;
      const order = { S: 1, M: 2, L: 3 };
      for (let i = 0; i < lu.length - 1; i++) { if (order[lu[i].Poste] > order[lu[i + 1].Poste]) return false; }
      return true;
    };
    const generateInsertions = (base, card) => {
      const out = [];
      for (let i = 0; i <= base.length; i++) {
        const test = [...base]; test.splice(i, 0, card);
        if (test.length === 5 && isValidLineup(test)) out.push(test);
      }
      return out;
    };
    const lineupUtility = (my, oppA, oppB, w = { off: 0.6, def: 0.4 }) => {
      const atk = (expectedAttackEV(my, oppA) + expectedAttackEV(my, oppB)) / 2;
      const def = (expectedConcedeEV(my, oppA) + expectedConcedeEV(my, oppB)) / 2;
      return w.off * atk - w.def * def;
    };

    // ==============================
    // DRAFT LOGIC HELPERS
    // ==============================
    /**
     * Ordre serpentin pour 3 √©quipes, DRAFT_PICKS_PER_TEAM picks chacune.
     * Total picks = 27. Serpentin : 0,1,2, 2,1,0, 0,1,2, 2,1,0, ...
     */
    const buildSerpentinOrder = (totalPicks) => {
      const order = [];
      let round = 0;
      while (order.length < totalPicks) {
        const base = [0, 1, 2];
        const seq = round % 2 === 0 ? base : [...base].reverse();
        for (const t of seq) { if (order.length < totalPicks) order.push(t); }
        round++;
      }
      return order;
    };
    /**
     * Serpentin 3 √©quipes en commen√ßant par `startTeam` (0/1/2).
     * Exemple startTeam=1 : 1,2,0, 0,2,1, 1,2,0, ...
     */
    const buildSerpentinOrderFromStarter = (totalPicks, startTeam) => {
    const base = [0, 1, 2];
    const rotated = base.slice(startTeam).concat(base.slice(0, startTeam)); // rotate
    const order = [];
    let round = 0;

    while (order.length < totalPicks) {
        const seq = round % 2 === 0 ? rotated : [...rotated].reverse();
        for (const t of seq) {
        if (order.length < totalPicks) order.push(t);
        }
        round++;
    }
    return order;
    };
    /**
     * √âvalue la valeur d'un pick pour l'IA.
     * L'IA cherche √† maximiser l'utilit√© de son roster complet (hand + picked).
     */
    const aiDraftValue = (card, currentHand, opponentHands) => {
      const newHand = [...currentHand, card];
      // Valeur intrins√®que
      const intrinsic = (Number(card.OFF) + Number(card.DEF)) / 2;
      // Synergie potentielle avec sa main actuelle
      const teamCounts = {};
      newHand.forEach(p => { const t = getTeamName(p); if (t) teamCounts[t] = (teamCounts[t] || 0) + 1; });
      const synergyBonus = Object.values(teamCounts).filter(c => c >= 2).length * 0.8;
      // Bloquer les adversaires : p√©nalise si la carte aurait √©t√© tr√®s utile pour un adversaire
      let blockBonus = 0;
      opponentHands.forEach(oppH => {
        const oppNew = [...oppH, card];
        const oppTeamCounts = {};
        oppNew.forEach(p => { const t = getTeamName(p); if (t) oppTeamCounts[t] = (oppTeamCounts[t] || 0) + 1; });
        const wouldGiveSynergy = Object.values(oppTeamCounts).filter(c => c >= 2).length >
          Object.values((() => { const c2 = {}; oppH.forEach(p => { const t = getTeamName(p); if (t) c2[t] = (c2[t] || 0) + 1; }); return c2; })()).filter(c => c >= 2).length;
        if (wouldGiveSynergy) blockBonus += 0.4;
      });
      // √âquilibre des postes
      const posteCounts = { S: 0, M: 0, L: 0 };
      newHand.forEach(p => { if (posteCounts[p.Poste] !== undefined) posteCounts[p.Poste]++; });
      const posteBalance = POSTES.every(pos => posteCounts[pos] <= 3) ? 0.3 : -0.5;
      return intrinsic + synergyBonus + blockBonus + posteBalance;
    };

    // ==============================
    // PLAYER CARD
    // ==============================
    const PlayerCard = ({
      player, synergyTeams, onClick, selected, disabled,
      isTarget, isAttacker, isJumping, canBeTargeted, size = "md", grayed = false
    }) => {
      if (!player) return null;
      const cardBaseWidth = "w-[18%]";
      const maxWidth = size === "sm" ? "max-w-[140px]" : "max-w-[180px]";
      const teamName = getTeamName(player);
      const isSynergy = !!teamName && synergyTeams?.has(teamName);
      const imgFolder = isSynergy ? "cartes3" : "cartes2";
      const offVal = synergyTeams ? effectiveOFF(player, synergyTeams) : (player.OFF ?? 0);
      const defVal = synergyTeams ? effectiveDEF(player, synergyTeams) : (player.DEF ?? 0);
      const ringClass = (() => {
        if (isSynergy) return "ring-2 md:ring-4 ring-violet-500 shadow-[0_0_22px_rgba(139,92,246,0.45)]";
        if (isTarget || isAttacker) return "ring-2 md:ring-4 ring-orange-500 z-30 scale-105";
        if (canBeTargeted) return "ring-2 md:ring-4 ring-yellow-400";
        if (selected) return "ring-2 md:ring-4 ring-blue-500 z-20";
        return "";
      })();
      return (
        <div
          onClick={(!disabled || canBeTargeted) && !grayed ? onClick : undefined}
          style={{ aspectRatio: "800/1117" }}
          className={`
            relative rounded-lg md:rounded-xl overflow-hidden
            transition-all duration-300 flex-shrink-0
            ${cardBaseWidth} ${maxWidth}
            bg-slate-800 shadow-2xl card-shadow
            ${grayed ? "opacity-30 cursor-not-allowed grayscale" : "cursor-pointer"}
            ${ringClass}
            ${isJumping ? "animate-bounce" : ""}
          `}
        >
          <img
            src={`${imgFolder}/${String(player.TEAM_y || player.TEAM_x || "").trim()}_card_${player.PLAYER_ID}.png`}
            alt={player.NAME}
            className="w-full h-full object-cover"
            onError={(e) => {
              e.target.onerror = null;
              e.target.src = `https://via.placeholder.com/800x1117/1e293b/ffffff?text=${player.NAME ? player.NAME.split(",")[0] : "N/A"}`;
            }}
          />
          <div className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black via-black/95 to-transparent p-1 md:p-1.5 pt-3 md:pt-4 text-[7px] md:text-[9px] lg:text-[11px]">
            <p className="font-black truncate uppercase text-white leading-none mb-1">{player.NAME ? player.NAME.split(",")[0] : "???"}</p>
            <div className="flex justify-between font-mono">
              <span className="font-bold text-orange-400">O{offVal}</span>
              <span className="font-bold text-blue-400">D{defVal}</span>
            </div>
          </div>
        </div>
      );
    };

    // ==============================
    // DRAFT CARD (pool)
    // ==============================
    const DraftPoolCard = ({ player, onPick, disabled, animIn, posteColor }) => {
      if (!player) return (
        <div className="flex flex-col items-center gap-3 opacity-30">
          <div className="w-full rounded-2xl bg-slate-800/40 border-2 border-dashed border-slate-700" style={{ aspectRatio: '800/1117', maxWidth: 200 }} />
        </div>
      );

      const posteColors = {
        S: { badge: 'bg-red-600', glow: 'rgba(239,68,68,0.35)', ring: 'ring-red-500/40', label: 'SMALL' },
        M: { badge: 'bg-green-600', glow: 'rgba(34,197,94,0.35)', ring: 'ring-green-500/40', label: 'MEDIUM' },
        L: { badge: 'bg-blue-600', glow: 'rgba(59,130,246,0.35)', ring: 'ring-blue-500/40', label: 'LARGE' },
      };
      const pc = posteColors[player.Poste] || posteColors.S;

      return (
        <div
          className={`
            flex flex-col items-center gap-3
            ${animIn ? 'draft-card-in' : ''}
            ${disabled ? 'disabled' : ''}
          `}
        >
          {/* Poste badge */}
          <div className={`flex items-center gap-2 px-3 py-1 rounded-full ${pc.badge} text-white font-black text-[10px] uppercase tracking-widest shadow-lg`}>
            <span>{player.Poste}</span>
            <span className="opacity-70">¬∑</span>
            <span>{pc.label}</span>
          </div>

          {/* Card */}
          <div
            onClick={disabled ? undefined : onPick}
            className={`
              draft-pool-card relative rounded-2xl overflow-hidden
              ${disabled ? 'disabled' : ''}
              ring-2 ${pc.ring}
            `}
            style={{
              width: '100%',
              maxWidth: 200,
              aspectRatio: '800/1117',
              boxShadow: disabled ? 'none' : `0 8px 32px ${pc.glow}`,
            }}
          >
            <img
              src={`cartes2/${String(player.TEAM_y || player.TEAM_x || '').trim()}_card_${player.PLAYER_ID}.png`}
              alt={player.NAME}
              className="w-full h-full object-cover"
              onError={(e) => {
                e.target.onerror = null;
                e.target.src = `https://via.placeholder.com/800x1117/1e293b/ffffff?text=${(player.NAME || '').split(',')[0]}`;
              }}
            />
            <div className="absolute bottom-0 left-0 right-0 bg-gradient-to-t from-black/95 via-black/80 to-transparent p-2 pt-6">
              <p className="font-black truncate uppercase text-white text-[10px] md:text-[12px] leading-none mb-1">
                {player.NAME ? player.NAME.split(",")[0] : "???"}
              </p>
              <div className="flex justify-between font-mono text-[10px]">
                <span className="font-bold text-orange-400">OFF {player.OFF}</span>
                <span className="font-bold text-blue-400">DEF {player.DEF}</span>
              </div>
              <div className="text-[9px] text-slate-400 font-bold mt-0.5 truncate">{getTeamName(player)}</div>
            </div>

            {/* Pick overlay */}
            {!disabled && (
              <div className="absolute inset-0 bg-gradient-to-b from-transparent to-transparent hover:from-orange-500/10 hover:to-orange-600/5 transition-all flex items-center justify-center opacity-0 hover:opacity-100">
                <div className="bg-orange-500 text-white font-black uppercase text-[11px] px-4 py-2 rounded-full shadow-2xl tracking-widest">
                  ‚úì DRAFTER
                </div>
              </div>
            )}
          </div>

          {/* Stats */}
          <div className="flex items-center gap-2">
            <span className="text-orange-400 font-black text-sm">O{player.OFF}</span>
            <span className="text-slate-600">¬∑</span>
            <span className="text-blue-400 font-black text-sm">D{player.DEF}</span>
          </div>
        </div>
      );
    };

    // ==============================
    // DRAFT MINI CARD (roster)
    // ==============================
    const DraftMiniCard = ({ player, teamId }) => {
    if (!player) return null;

    const teamColors = [
        'border-orange-500/40 bg-orange-500/5',
        'border-red-500/40 bg-red-500/5',
        'border-purple-500/40 bg-purple-500/5',
    ];

    const posteColors = {
        S: 'bg-red-600',
        M: 'bg-green-600',
        L: 'bg-blue-600',
    };

    return (
        <div
        className={`
            picked-bounce
            flex items-center justify-between
            px-3 py-2.5
            rounded-xl border
            ${teamColors[teamId]}
            w-full
        `}
        >
        {/* LEFT : Nom + Club */}
        <div className="flex flex-col min-w-0">
            <p className="font-black text-[12px] text-white truncate uppercase leading-none">
            {(player.NAME || '').split(',')[0]}
            </p>
            <p className="text-[9px] text-slate-400 font-bold truncate">
            {getTeamName(player)}
            </p>
        </div>

        {/* CENTER : STATS PLUS GROSSES */}
        <div className="flex items-center gap-2">
            <div className="px-2 py-1 rounded-lg bg-orange-500/15">
            <span className="text-[14px] font-black text-orange-400 tracking-tight">
                O{player.OFF}
            </span>
            </div>

            <div className="px-2 py-1 rounded-lg bg-blue-500/15">
            <span className="text-[14px] font-black text-blue-400 tracking-tight">
                D{player.DEF}
            </span>
            </div>
        </div>

        {/* RIGHT : Poste */}
        <div
            className={`
            ${posteColors[player.Poste] || 'bg-slate-600'}
            text-white font-black text-[10px]
            px-2.5 py-0.5 rounded-md
            flex-shrink-0
            `}
        >
            {player.Poste}
        </div>
        </div>
    );
    };

    // ==============================
    // DRAFT SCREEN
    // ==============================
    const DraftScreen = ({ allPlayers, onDraftComplete, onBack }) => {
      const names = ["VOUS", "IA 1", "IA 2"];
      const teamColors = [
        { text: 'text-orange-400', bg: 'bg-orange-500', border: 'border-orange-500/40', light: 'bg-orange-500/10' },
        { text: 'text-red-400', bg: 'bg-red-500', border: 'border-red-500/40', light: 'bg-red-500/10' },
        { text: 'text-purple-400', bg: 'bg-purple-500', border: 'border-purple-500/40', light: 'bg-purple-500/10' },
      ];
      const totalPicks = DRAFT_PICKS_PER_TEAM * 3;

      // ---- STATE (minimal ‚Äî toute la logique passe par les refs) ----
      const [renderTick, setRenderTick] = useState(0); // force re-render
        // Tirage au sort du 1er pick
        const [startingTeam, setStartingTeam] = useState(null); // 0/1/2
        const [showDraftDraw, setShowDraftDraw] = useState(true);
        const [draftOrder, setDraftOrder] = useState(null);
      const forceRender = () => setRenderTick(t => t + 1);

      // ---- REFS (source de v√©rit√©, jamais stale) ----
      const pickedRef       = useRef([[], [], []]);
      const remainingRef    = useRef(null);   // { S:[...], M:[...], L:[...] }
      const poolRef         = useRef(null);   // { S: card|null, M: card|null, L: card|null }
      const pickIndexRef    = useRef(0);
      const busyRef         = useRef(false);  // emp√™che tout double-d√©clenchement
      const isDoneRef       = useRef(false);
      const draftLogRef     = useRef([]);
      const pickingAnimRef  = useRef(null);   // poste en animation de s√©lection
      const poolKeyRef      = useRef(0);      // force animation d'entr√©e du pool

      // ---- Initialisation ----
      useEffect(() => {
        if (!allPlayers.length) return;
        const byPoste = {};
        POSTES.forEach(p => {
          byPoste[p] = [...allPlayers.filter(c => String(c.Poste||'').trim().toUpperCase() === p)]
            .sort(() => Math.random() - 0.5);
        });
        remainingRef.current = byPoste;
        // Construire le premier pool
        const newPool = {};
        POSTES.forEach(p => {
        newPool[p] = [
            byPoste[p]?.[0] || null,
            byPoste[p]?.[1] || null,
        ];
        });
        poolRef.current = newPool;
        poolKeyRef.current += 1;

        // --- Tirage au sort du 1er pick + ordre serpentin dynamique ---
        const starter = Math.floor(Math.random() * 3); // 0/1/2
        setStartingTeam(starter);
        setDraftOrder(buildSerpentinOrderFromStarter(totalPicks, starter));

        // Afficher l'√©cran "tirage" un court instant
        setShowDraftDraw(true);
        setTimeout(() => setShowDraftDraw(false), 1700);

        forceRender();
      }, [allPlayers]);

      // ---- Logique centrale : apr√®s chaque render, d√©cider si l'IA doit jouer ----
      const aiTimerRef = useRef(null);

        useEffect(() => {
        if (!draftOrder) return;
        if (!poolRef.current || isDoneRef.current) return;

        const idx = pickIndexRef.current;
        if (idx >= totalPicks) return;

        const team = draftOrder[idx];
        if (team === 0) return; // humain

        // si d√©j√† en train de r√©fl√©chir ou timer d√©j√† planifi√© ‚Üí stop
        if (busyRef.current || aiTimerRef.current) return;

        busyRef.current = true;

        const delay = 1800 + Math.random() * 1200;

        aiTimerRef.current = setTimeout(() => {
            aiTimerRef.current = null;

            const pool = poolRef.current;
            const currentPicked = pickedRef.current[team];
            const available = POSTES.flatMap(p => (pool[p] || [])).filter(Boolean);
            const oppHands = [0, 1, 2].filter(x => x !== team).map(x => pickedRef.current[x]);

            if (!available.length) {
            busyRef.current = false;
            forceRender();
            return;
            }

            const valid = available.filter(card =>
            currentPicked.filter(p => p.Poste === card.Poste).length < 3
            );
            const candidates = valid.length ? valid : available;

            const best = candidates.reduce((acc, card) => {
            const val = aiDraftValue(card, currentPicked, oppHands);
            return val > acc.val ? { card, val } : acc;
            }, { card: candidates[0], val: -Infinity });

            executePick(best.card, team, idx);
        }, delay);

        // IMPORTANT : cleanup uniquement au d√©montage / changement draftOrder
        return () => {
            if (aiTimerRef.current) {
            clearTimeout(aiTimerRef.current);
            aiTimerRef.current = null;
            busyRef.current = false; // √©vite le blocage si on annule
            }
        };
        }, [draftOrder, renderTick]); // renderTick = ton ‚Äúsignal‚Äù de progression

      // ---- Fonction centrale de pick (synchrone sur les refs) ----
      const executePick = (card, team, idx) => {
        if (!card) { busyRef.current = false; return; }

        // Phase 1 : animation de s√©lection
        pickingAnimRef.current = String(card.PLAYER_ID);
        forceRender();

        setTimeout(() => {
          // Phase 2 : appliquer le pick sur les refs
          pickingAnimRef.current = null;

          // Ajouter √† l'√©quipe
          pickedRef.current = pickedRef.current.map((arr, tid) =>
            tid === team ? [...arr, card] : arr
          );

          // Retirer la carte de la file et reconstruire le pool
          const rem = { ...remainingRef.current };
          rem[card.Poste] = rem[card.Poste].filter(c => c.PLAYER_ID !== card.PLAYER_ID);
          remainingRef.current = rem;
            const newPool = {};
            POSTES.forEach(p => {
            newPool[p] = [
                rem[p]?.[0] || null,
                rem[p]?.[1] || null,
            ];
            });
            poolRef.current = newPool;
          poolKeyRef.current += 1;

          // Log
          draftLogRef.current = [
            `${names[team]} ‚Üí ${card.NAME.split(',')[0]} (${card.Poste})`,
            ...draftLogRef.current
          ].slice(0, 20);

          // Avancer l'index
          const nextIdx = idx + 1;
          pickIndexRef.current = nextIdx;

          if (nextIdx >= totalPicks) {
            isDoneRef.current = true;
          }

          busyRef.current = false;
          forceRender(); // d√©clenche un re-render ‚Üí l'useEffect v√©rifiera si l'IA doit encore jouer
        }, 650);
      };

      // ---- Clic humain ----
      const handleHumanPick = (card) => {
        if (busyRef.current || isDoneRef.current) return;
        if (!card) return;
        const idx = pickIndexRef.current;
        if (idx >= totalPicks) return;
        const team = draftOrder[idx];
        if (team !== 0) return;
        if (pickedRef.current[0].filter(p => p.Poste === card.Poste).length >= 3) return;
        busyRef.current = true;
        executePick(card, 0, idx);
      };

      // Lancer la partie avec les picks
      const handleStartGame = () => {
        onDraftComplete(pickedRef.current);
      };

      // ---- Lecture des refs pour le rendu ----
      const picked       = pickedRef.current;
      const pool         = poolRef.current;
      const currentPickIndex = pickIndexRef.current;
      const isDone       = isDoneRef.current;
      const draftLog     = draftLogRef.current;
      const pickingAnim  = pickingAnimRef.current;
      const poolKey      = poolKeyRef.current;
      const isBusy       = busyRef.current;

      const currentTeam  = (draftOrder && currentPickIndex < totalPicks) ? draftOrder[currentPickIndex] : -1;

      const isHumanTurn  = currentTeam === 0 && !isBusy && !isDone;
      const postePicksLeft = (tid, poste) => 3 - picked[tid].filter(p => p.Poste === poste).length;
      const progress     = (currentPickIndex / totalPicks) * 100;
      const upcomingTurns = draftOrder ? draftOrder.slice(currentPickIndex, currentPickIndex + 6) : [];

      if (!pool) {
        return (
          <div className="draft-bg min-h-screen flex items-center justify-center">
            <div className="text-slate-400 font-bold">Initialisation du draft...</div>
          </div>
        );
      }

        // √âcran tirage au sort
        if (showDraftDraw && startingTeam !== null) {
        return (
            <div className="draft-bg min-h-screen flex items-center justify-center">
            <div className="bg-black/70 border border-orange-500/30 rounded-3xl p-10 text-center shadow-2xl">
                <div className="font-display font-black italic uppercase text-4xl text-white mb-4">
                üé≤ Tirage au sort
                </div>
                <div className="text-2xl font-black text-orange-400">
                {names[startingTeam]} commence le draft !
                </div>
                <div className="mt-3 text-slate-500 text-sm font-bold">
                Ordre serpentin activ√© üêç
                </div>
            </div>
            </div>
        );
        }
      if (!draftOrder) {
        return (
            <div className="draft-bg min-h-screen flex items-center justify-center">
            <div className="text-slate-400 font-bold">Pr√©paration du draft...</div>
            </div>
        );
        }
      return (
        <div className="draft-bg min-h-screen flex flex-col">
          {/* Header */}
          <div className="flex-shrink-0 border-b border-slate-800/80 bg-black/40 backdrop-blur px-4 py-3">
            <div className="max-w-7xl mx-auto flex items-center gap-4 flex-wrap">
              <button onClick={onBack} className="flex items-center gap-2 text-slate-400 hover:text-white transition-colors font-bold text-sm flex-shrink-0">
                <Icons.ArrowLeft /> Retour
              </button>

              <div className="flex-1 flex flex-col items-center min-w-0">
                <div className="flex items-center gap-2">
                  <div className="w-6 h-6 rounded-lg bg-orange-500/20 flex items-center justify-center">
                    <Icons.Draft />
                  </div>
                  <span className="font-display font-black italic uppercase text-white text-lg tracking-tight">MODE DRAFT</span>
                </div>
                <div className="w-full max-w-xs mt-1 flex items-center gap-2">
                  <div className="flex-1 h-1.5 bg-slate-800 rounded-full overflow-hidden">
                    <div className="h-full bg-gradient-to-r from-orange-500 to-yellow-500 rounded-full transition-all duration-500" style={{ width: `${progress}%` }} />
                  </div>
                  <span className="text-[10px] font-black text-slate-500 whitespace-nowrap">{currentPickIndex}/{totalPicks}</span>
                </div>
              </div>

              {!isDone && (
                <div className="flex items-center gap-1.5 flex-shrink-0">
                  <span className="text-[9px] font-black text-slate-600 uppercase tracking-widest mr-1">Prochain :</span>
                  {upcomingTurns.map((tid, i) => (
                    <div key={i} className={`w-6 h-6 rounded-full flex items-center justify-center font-black text-[9px] ${i === 0 ? `${teamColors[tid].bg} text-white shadow-lg ${tid === 0 ? 'active-turn-glow' : ''}` : 'bg-slate-800 text-slate-500'}`}>
                      {tid === 0 ? 'V' : tid}
                    </div>
                  ))}
                </div>
              )}
            </div>
          </div>

          {/* Main */}
          <div className="flex-1 overflow-y-auto scrollbar-hide">
          <div className="max-w-7xl mx-auto p-4 md:p-6 grid grid-cols-1 lg:grid-cols-12 gap-6">

            {/* LEFT: Rosters */}
            <div className="lg:col-span-3 space-y-4 order-2 lg:order-1">
              {[0, 1, 2].map(tid => (
                <div key={tid} className={`rounded-2xl border ${teamColors[tid].border} ${teamColors[tid].light} p-3`}>
                  <div className="flex items-center justify-between mb-2">
                    <div className="flex items-center gap-2">
                      {tid === currentTeam && !isDone && (
                        <div className={`w-2 h-2 rounded-full ${teamColors[tid].bg} ${tid !== 0 ? 'ai-thinking' : 'active-turn-glow'}`} />
                      )}
                      <span className={`font-display font-black italic uppercase text-sm ${teamColors[tid].text}`}>{names[tid]}</span>
                    </div>
                    <span className="text-[10px] font-black text-slate-500">{picked[tid].length}/{DRAFT_PICKS_PER_TEAM}</span>
                  </div>
                  <div className="space-y-1">
                    {POSTES.map(poste => {
                      const cards = picked[tid].filter(p => p.Poste === poste);
                      return (
                        <div key={poste}>
                          <div className="text-[8px] font-black text-slate-600 uppercase tracking-widest mb-0.5 flex items-center gap-1">
                            <span className={`px-1.5 py-0.5 rounded text-white font-black text-[7px] ${poste === 'S' ? 'bg-red-600' : poste === 'M' ? 'bg-green-600' : 'bg-blue-600'}`}>{poste}</span>
                            {Array.from({ length: 3 }).map((_, i) => (
                              <span key={i} className={`w-1.5 h-1.5 rounded-full ${i < cards.length ? teamColors[tid].bg : 'bg-slate-800'}`} />
                            ))}
                          </div>
                          {cards.map((c, i) => <DraftMiniCard key={i} player={c} teamId={tid} />)}
                        </div>
                      );
                    })}
                  </div>
                </div>
              ))}
            </div>

            {/* CENTER */}
            <div className="lg:col-span-6 flex flex-col items-center gap-6 order-1 lg:order-2">
              {!isDone ? (
                <>
                  {/* Banni√®re tour */}
                  <div className={`w-full rounded-2xl p-4 border text-center ${teamColors[currentTeam >= 0 ? currentTeam : 0]?.border || 'border-slate-700'} ${teamColors[currentTeam >= 0 ? currentTeam : 0]?.light || 'bg-slate-900/30'} ${currentTeam === 0 ? 'active-turn-glow' : ''}`}>
                    {currentTeam === 0 ? (
                      <>
                        <div className="font-display font-black italic uppercase text-2xl text-white">üéØ Votre tour !</div>
                        <div className="text-slate-400 text-[11px] font-bold mt-1">
                          Choisissez une carte ¬∑ {POSTES.map(p => `${postePicksLeft(0, p)}${p}`).join(' ¬∑ ')} restants
                        </div>
                      </>
                    ) : currentTeam > 0 ? (
                      <>
                        <div className={`font-display font-black italic uppercase text-2xl ${teamColors[currentTeam].text}`}>
                          ‚è≥ {names[currentTeam]} drafte...
                        </div>
                        <div className="text-slate-500 text-[11px] font-bold mt-1 ai-thinking">Analyse du pool en cours</div>
                      </>
                    ) : null}
                  </div>

                  {/* Pool de 3 cartes */}
                    <div key={poolKey} className="grid grid-cols-3 gap-4 w-full">
                    {POSTES.map((poste, colIdx) => {
                        const cards = (pool[poste] || []).filter(Boolean);

                        return (
                        <div key={poste} className="flex flex-col items-center gap-4">
                            {cards.map((card, rowIdx) => {
                            const isDisabled =
                                !isHumanTurn ||
                                !card ||
                                pickingAnim !== null ||
                                (picked[0].filter(p => p.Poste === poste).length >= 3);

                            const isPicking = pickingAnim === String(card.PLAYER_ID);

                            return (
                                <div
                                key={String(card.PLAYER_ID)}
                                className={isPicking ? "draft-card-pick" : `draft-card-in-${Math.min(colIdx + 1, 3)}`}
                                >
                                <DraftPoolCard
                                    player={card}
                                    onPick={() => handleHumanPick(card)}
                                    disabled={isDisabled}
                                    animIn={false}
                                />
                                </div>
                            );
                            })}

                            {/* si jamais tu veux garder un ‚Äúespace vide‚Äù quand une des 2 cartes manque */}
                            {cards.length < 2 && (
                            <DraftPoolCard player={null} disabled={true} animIn={false} />
                            )}

                            {currentTeam === 0 && (
                            <div className="mt-1 flex gap-1">
                                {Array.from({ length: 3 }).map((_, j) => (
                                <div
                                    key={j}
                                    className={`w-2 h-2 rounded-full transition-all ${
                                    j < picked[0].filter(p => p.Poste === poste).length ? "bg-orange-500" : "bg-slate-700"
                                    }`}
                                />
                                ))}
                            </div>
                            )}
                        </div>
                        );
                    })}
                    </div>

                  <div className="w-full bg-slate-900/60 border border-slate-800 rounded-2xl p-3 text-center">
                    <p className="text-[10px] text-slate-500 font-bold">
                      Objectif : <span className="text-white">3S + 3M + 3L</span> par √©quipe ¬∑ Ordre serpentin ¬∑
                      <span className="text-yellow-400"> Victoire √† {typeof window !== 'undefined' && window._basketArenaTargetScore ? window._basketArenaTargetScore : 8} pts</span>
                    </p>
                  </div>
                </>
              ) : (
                <div className="w-full flex flex-col items-center gap-6">
                  <div className="text-center">
                    <div className="font-display font-black italic uppercase text-4xl text-white mb-2">‚úÖ Draft termin√© !</div>
                    <p className="text-slate-400 font-bold text-sm">Toutes les √©quipes sont constitu√©es. Pr√™t √† jouer ?</p>
                  </div>
                    {[0, 1, 2].map(tid => {
                    const roster = picked[tid];
                    const countByPoste = (poste) => roster.filter(p => p.Poste === poste).length;

                    const posteMeta = {
                        S: { label: 'SMALL',  accent: 'red',   border: 'border-red-500/30',   bg: 'bg-red-500/5',   text: 'text-red-300' },
                        M: { label: 'MEDIUM', accent: 'green', border: 'border-green-500/30', bg: 'bg-green-500/5', text: 'text-green-300' },
                        L: { label: 'LARGE',  accent: 'blue',  border: 'border-blue-500/30',  bg: 'bg-blue-500/5',  text: 'text-blue-300' },
                    };

                    return (
                        <div
                        key={tid}
                        className={`
                            w-full rounded-3xl border ${teamColors[tid].border} ${teamColors[tid].light}
                            p-4 md:p-5
                            shadow-[0_18px_60px_rgba(0,0,0,0.35)]
                            backdrop-blur
                        `}
                        >
                        {/* Header */}
                        <div className="flex items-center justify-between mb-4">
                            <div className="flex items-center gap-2">
                            <div className={`w-9 h-9 rounded-2xl ${teamColors[tid].bg} text-white flex items-center justify-center font-black text-sm shadow-lg`}>
                                {tid === 0 ? 'V' : tid}
                            </div>
                            <div>
                                <div className={`font-display font-black italic uppercase text-lg ${teamColors[tid].text} leading-none`}>
                                {names[tid]}
                                </div>
                                <div className="text-[10px] text-slate-500 font-black uppercase tracking-widest mt-0.5">
                                Roster final
                                </div>
                            </div>
                            </div>

                            <div className="px-3 py-1 rounded-2xl bg-black/30 border border-slate-800 text-[10px] font-black text-slate-300">
                            {roster.length}/{DRAFT_PICKS_PER_TEAM}
                            </div>
                        </div>

                        {/* Columns */}
                        <div className="grid grid-cols-1 md:grid-cols-3 gap-3">
                            {POSTES.map((poste) => {
                            const meta = posteMeta[poste];
                            const list = roster.filter(p => p.Poste === poste);

                            return (
                                <div
                                key={poste}
                                className={`
                                    rounded-2xl border ${meta.border} ${meta.bg}
                                    p-3
                                    shadow-inner
                                `}
                                >
                                {/* Poste header */}
                                <div className="flex items-center justify-between mb-2">
                                    <div className="flex items-center gap-2">
                                    <span className={`px-2 py-1 rounded-lg bg-${meta.accent}-600 text-white font-black text-[10px]`}>
                                        {poste}
                                    </span>
                                    <span className={`text-[10px] font-black uppercase tracking-widest ${meta.text}`}>
                                        {meta.label}
                                    </span>
                                    </div>
                                    <div className="flex items-center gap-1">
                                    {Array.from({ length: 3 }).map((_, i) => (
                                        <span
                                        key={i}
                                        className={`w-2 h-2 rounded-full ${i < countByPoste(poste) ? `bg-${meta.accent}-500` : 'bg-slate-800'}`}
                                        />
                                    ))}
                                    </div>
                                </div>

                                {/* Players */}
                                <div className="space-y-2">
                                    {list.map((c, i) => (
                                    <div
                                        key={i}
                                        className="
                                        flex items-center justify-between gap-2
                                        px-3 py-2 rounded-xl
                                        bg-slate-950/40 border border-slate-800/70
                                        hover:border-orange-500/30 transition-colors
                                        "
                                    >
                                        <div className="min-w-0">
                                        <div className="text-[11px] font-black text-white truncate uppercase leading-none">
                                            {c.NAME.split(',')[0]}
                                        </div>
                                        <div className="text-[9px] text-slate-500 font-bold truncate">
                                            {getTeamName(c)}
                                        </div>
                                        </div>

                                        <div className="flex items-center gap-1.5 flex-shrink-0">
                                        <span className="px-2 py-1 rounded-lg bg-orange-500/15 text-orange-300 font-black text-[12px]">
                                            O{c.OFF}
                                        </span>
                                        <span className="px-2 py-1 rounded-lg bg-blue-500/15 text-blue-300 font-black text-[12px]">
                                            D{c.DEF}
                                        </span>
                                        </div>
                                    </div>
                                    ))}

                                    {list.length === 0 && (
                                    <div className="text-[10px] text-slate-600 font-bold text-center py-4">
                                        Aucun joueur
                                    </div>
                                    )}
                                </div>
                                </div>
                            );
                            })}
                        </div>
                        </div>
                    );
                })}
                  <button onClick={handleStartGame} className="home-btn w-full max-w-sm bg-gradient-to-r from-orange-600 to-orange-500 hover:from-orange-500 hover:to-orange-400 text-white py-5 rounded-2xl font-display font-black text-2xl italic uppercase tracking-wider shadow-2xl pulse-glow flex items-center justify-center gap-3">
                    <Icons.Play /> LANCER LE MATCH
                  </button>
                </div>
              )}
            </div>

            {/* RIGHT: Log */}
            <div className="lg:col-span-3 order-3">
              <div className="bg-black/50 backdrop-blur rounded-3xl p-4 border border-slate-800 h-fit max-h-[500px] overflow-hidden flex flex-col">
                <div className="flex items-center gap-2 mb-3 text-[10px] font-black text-slate-500 uppercase tracking-widest">
                  <Icons.History /> Historique du draft
                </div>
                <div className="overflow-y-auto flex-1 space-y-1.5 pr-1 scrollbar-hide">
                  {draftLog.length === 0 ? (
                    <div className="text-slate-600 text-[10px] font-bold text-center py-4">En attente du premier pick...</div>
                  ) : draftLog.map((log, i) => {
                    const teamName = log.split(' ‚Üí ')[0];
                    const tid = names.indexOf(teamName);
                    return (
                      <div key={i} className={`slide-right p-2 rounded-xl text-[10px] font-bold leading-snug ${i === 0 ? `${teamColors[tid >= 0 ? tid : 0].light} border ${teamColors[tid >= 0 ? tid : 0].border} ${teamColors[tid >= 0 ? tid : 0].text}` : 'bg-slate-800/30 text-slate-500'}`}>
                        {log}
                      </div>
                    );
                  })}
                </div>
              </div>
            </div>

          </div>
          </div>
        </div>
      );
    };

    // ==============================
    // ROLE DRAW MODAL
    // ==============================
    const RoleDrawModal = ({ open, tick, phase, result, onSkip }) => {
      if (!open) return null;
      const names = ["VOUS", "IA 1", "IA 2"];
      const spinningName = (offset) => names[(tick + offset) % 3];
      const attackerLabel = phase === "SPIN" ? spinningName(0) : names[result.attacker];
      const defenderLabel = phase === "SPIN" ? spinningName(1) : names[result.defender];
      const pausedLabel   = phase === "SPIN" ? spinningName(2) : names[result.paused];
      const Box = ({ title, value, accent }) => (
        <div className={`rounded-3xl border p-5 text-center bg-slate-950/60 shadow-2xl ${accent}`}>
          <div className="text-[10px] font-black uppercase tracking-widest text-slate-400">{title}</div>
          <div className={`mt-3 font-display font-black italic uppercase text-3xl md:text-4xl ${phase === "SPIN" ? "opacity-80" : ""}`}>{value}</div>
          {phase === "SPIN" && <div className="mt-3 text-[10px] font-bold text-slate-500 uppercase tracking-widest">Tirage en cours...</div>}
        </div>
      );
      return (
        <div className="fixed inset-0 z-[999] flex items-center justify-center p-4">
          <div className="absolute inset-0 bg-black/85 backdrop-blur-md" />
          <div className="relative w-full max-w-3xl rounded-3xl border border-orange-500/25 bg-slate-950 shadow-2xl overflow-hidden">
            <div className="p-6 md:p-8">
              <div className="text-center mb-6">
                <div className="font-display font-black italic uppercase text-3xl md:text-4xl text-white">üé≤ Tirage au sort</div>
                <div className="text-slate-400 text-sm font-bold mt-2">Qui attaque ? Qui d√©fend ? Qui est en pause ?</div>
              </div>
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                <Box title="ATTAQUE" value={attackerLabel} accent="border-yellow-500/30" />
                <Box title="D√âFENSE" value={defenderLabel} accent="border-slate-400/30" />
                <Box title="PAUSE" value={pausedLabel} accent="border-blue-500/30" />
              </div>
              <div className="mt-6 flex items-center justify-center gap-3">
                {phase === "SPIN" ? (
                  <div className="text-slate-500 text-xs font-black uppercase tracking-widest">Attribution des r√¥les...</div>
                ) : (
                  <div className="text-green-400 text-xs font-black uppercase tracking-widest">R√¥les attribu√©s ‚úÖ</div>
                )}
              </div>
              <div className="mt-6 flex justify-center">
                <button onClick={onSkip} className="px-5 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 text-slate-200 font-black uppercase text-xs">
                  Ignorer l'animation
                </button>
              </div>
            </div>
          </div>
        </div>
      );
    };

    // ==============================
    // SCORE SELECT MODAL
    // ==============================
    const ScoreSelectModal = ({ value, onDec, onInc, onCancel, onConfirm, mode, setMode }) => (
      <div className="fixed inset-0 z-[999] flex items-center justify-center p-4">
        <div onClick={onCancel} className="absolute inset-0 bg-black/80 backdrop-blur-sm" />
        <div className="relative w-full max-w-md rounded-3xl border border-orange-500/30 bg-slate-950 shadow-2xl overflow-hidden">
          <div className="p-6 text-center">
            <div className="w-16 h-16 rounded-2xl bg-orange-500/15 border border-orange-500/30 flex items-center justify-center mx-auto mb-4">
              <Icons.Trophy size={28} />
            </div>
            <h3 className="font-display font-black text-2xl md:text-3xl italic uppercase text-white">Nouvelle Partie</h3>

            {/* Mode selection */}
            <div className="mt-5 grid grid-cols-2 gap-3">
              <button
                onClick={() => setMode('classic')}
                className={`py-3 rounded-2xl border font-black uppercase text-sm transition-all ${mode === 'classic' ? 'bg-orange-600 border-orange-500 text-white shadow-xl' : 'bg-slate-900 border-slate-700 text-slate-400 hover:border-slate-500'}`}
              >
                üé≤ Classique
              </button>
              <button
                onClick={() => setMode('draft')}
                className={`py-3 rounded-2xl border font-black uppercase text-sm transition-all ${mode === 'draft' ? 'bg-purple-700 border-purple-500 text-white shadow-xl' : 'bg-slate-900 border-slate-700 text-slate-400 hover:border-slate-500'}`}
              >
                ‚ú¶ Draft
              </button>
            </div>


            <p className="text-slate-400 text-sm font-bold mt-5 mb-2">Score de victoire (6‚Äì10)</p>
            <div className="flex items-center justify-center gap-6">
              <button onClick={onDec} className="w-14 h-14 rounded-2xl bg-slate-900 border border-slate-700 hover:border-orange-500/60 hover:bg-slate-800 transition-all font-black text-3xl">-</button>
              <div className="w-24 h-24 rounded-3xl bg-gradient-to-br from-orange-500 to-yellow-500 text-black flex items-center justify-center shadow-[0_0_45px_rgba(249,115,22,0.35)] border-4 border-white/20">
                <span className="font-display font-black italic text-5xl leading-none">{value}</span>
              </div>
              <button onClick={onInc} className="w-14 h-14 rounded-2xl bg-slate-900 border border-slate-700 hover:border-orange-500/60 hover:bg-slate-800 transition-all font-black text-3xl">+</button>
            </div>

            <div className="mt-6 grid grid-cols-2 gap-3">
              <button onClick={onCancel} className="py-3 rounded-2xl bg-slate-800 hover:bg-slate-700 text-slate-200 font-black uppercase text-sm">Annuler</button>
              <button
                onClick={onConfirm}
                className={`py-3 rounded-2xl text-white font-black uppercase text-sm shadow-xl ${mode === 'draft' ? 'bg-purple-700 hover:bg-purple-600' : 'bg-orange-600 hover:bg-orange-500'}`}
              >
                {mode === 'draft' ? '‚ú¶ D√©marrer Draft' : 'Jouer'}
              </button>
            </div>
          </div>
          <div className="px-6 py-4 border-t border-slate-800 bg-slate-950/60 text-center">
            <p className="text-[10px] font-black uppercase tracking-widest text-slate-500">Premier √† {value} points gagne</p>
          </div>
        </div>
      </div>
    );

    // ==============================
    // HOME SCREEN
    // ==============================
    const HomeScreen = ({ onStartGame, onRules, onCards, targetScore, setTargetScore, showScoreModal, setShowScoreModal, gameMode, setGameMode }) => (
      <div className="home-bg min-h-screen flex flex-col items-center justify-center p-6 relative overflow-hidden">
        <div className="absolute inset-0 overflow-hidden pointer-events-none">
          <div className="absolute top-1/4 left-1/4 w-96 h-96 rounded-full bg-orange-500/5 blur-3xl" />
          <div className="absolute bottom-1/4 right-1/4 w-96 h-96 rounded-full bg-yellow-500/5 blur-3xl" />
          <div className="absolute top-0 left-1/2 w-px h-full bg-gradient-to-b from-transparent via-orange-500/10 to-transparent" />
        </div>

        <div className="fade-in-up text-center mb-12 relative z-10">
          <div className="flex items-center justify-center gap-4 mb-6">
            <div className="w-28 h-28 md:w-32 md:h-32 rounded-3xl flex items-center justify-center bg-gradient-to-br from-slate-900 via-black to-slate-950 border border-orange-500/40 shadow-[0_0_55px_rgba(249,115,22,0.35)]">
              <BasketLogo size={72} className="object-contain drop-shadow-[0_4px_14px_rgba(0,0,0,0.75)]" />
            </div>
          </div>
          <h1 className="font-display text-7xl md:text-9xl font-black italic uppercase leading-none tracking-tighter text-white"
            style={{ textShadow: "0 0 60px rgba(249,115,22,0.4), 0 4px 0 rgba(0,0,0,0.5)" }}>BASKET</h1>
          <h2 className="font-display text-4xl md:text-6xl font-black italic uppercase leading-none tracking-tighter"
            style={{ background: "linear-gradient(135deg, #f97316, #eab308)", WebkitBackgroundClip: "text", WebkitTextFillColor: "transparent" }}>ARENA</h2>
          <p className="text-slate-500 font-display text-lg uppercase tracking-[0.3em] mt-3 font-bold">BY GPAIN1999</p>
        </div>

        <div className="relative z-10 w-full max-w-sm space-y-4">
          <button onClick={() => setShowScoreModal(true)}
            className="home-btn w-full bg-gradient-to-r from-orange-600 to-orange-500 hover:from-orange-500 hover:to-orange-400 text-white py-5 rounded-2xl font-display font-black text-2xl italic uppercase tracking-wider shadow-2xl pulse-glow flex items-center justify-center gap-3 fade-in-up-1">
            <Icons.Play /> JOUER
          </button>
          <button onClick={onRules}
            className="home-btn w-full bg-slate-800/80 hover:bg-slate-700/80 border border-slate-700 hover:border-slate-500 text-white py-4 rounded-2xl font-display font-black text-xl italic uppercase tracking-wider shadow-xl flex items-center justify-center gap-3 fade-in-up-2">
            <Icons.Book /> R√àGLES DU JEU
          </button>
          <button onClick={onCards}
            className="home-btn w-full bg-slate-800/80 hover:bg-slate-700/80 border border-slate-700 hover:border-slate-500 text-white py-4 rounded-2xl font-display font-black text-xl italic uppercase tracking-wider shadow-xl flex items-center justify-center gap-3 fade-in-up-3">
            <Icons.Cards /> TOUTES LES CARTES
          </button>
        </div>

        <p className="absolute bottom-6 text-slate-700 text-xs font-bold uppercase tracking-widest fade-in-up-4">
          Premier √† {targetScore} points remporte la partie
        </p>

        {showScoreModal && (
          <ScoreSelectModal
            value={targetScore}
            onDec={() => setTargetScore(v => Math.max(6, v - 1))}
            onInc={() => setTargetScore(v => Math.min(10, v + 1))}
            onCancel={() => setShowScoreModal(false)}
            onConfirm={() => { setShowScoreModal(false); onStartGame(); }}
            mode={gameMode}
            setMode={setGameMode}
          />
        )}
      </div>
    );

    // ==============================
    // OVERLAY MODAL
    // ==============================
    const OverlayModal = ({ onClose, children }) => (
      <div className="fixed inset-0 z-[900] flex flex-col">
        <div onClick={onClose} className="absolute inset-0 bg-black/80 backdrop-blur-sm" />
        <div className="relative z-10 flex flex-col h-full max-w-4xl w-full mx-auto my-4 md:my-8 rounded-3xl overflow-hidden border border-slate-700 bg-slate-950 shadow-2xl">
          {children}
        </div>
      </div>
    );

    // ==============================
    // RULES SCREEN
    // ==============================
    const RulesScreen = ({ onBack, backLabel, targetScore = 8 }) => {
      const RuleBlock = ({ icon, title, color, borderColor, children }) => (
        <div className="rule-section mb-6" style={{ borderColor }}>
          <div className="flex items-center gap-2 mb-3">
            <span className="text-xl">{icon}</span>
            <h3 className="font-display font-black text-xl italic uppercase" style={{ color }}>{title}</h3>
          </div>
          <div className="text-slate-300 text-sm leading-relaxed space-y-2">{children}</div>
        </div>
      );
      const Tag = ({ color = 'orange', children }) => {
        const colors = { orange:'bg-orange-500/20 text-orange-300 border-orange-500/30', yellow:'bg-yellow-500/20 text-yellow-300 border-yellow-500/30', blue:'bg-blue-500/20 text-blue-300 border-blue-500/30', green:'bg-green-500/20 text-green-300 border-green-500/30', red:'bg-red-500/20 text-red-300 border-red-500/30', slate:'bg-slate-500/20 text-slate-300 border-slate-500/30' };
        return <span className={`inline-block px-2 py-0.5 rounded text-xs font-black border ${colors[color]} mr-1`}>{children}</span>;
      };
      return (
        <div className="min-h-0 flex flex-col flex-1 overflow-hidden bg-slate-950">
          <div className="flex-shrink-0 bg-slate-950/95 backdrop-blur border-b border-slate-800 px-4 py-4">
            <div className="max-w-3xl mx-auto flex items-center gap-4">
              <button onClick={onBack} className="flex items-center gap-2 text-slate-400 hover:text-white transition-colors font-bold text-sm">
                <Icons.ArrowLeft /> {backLabel || 'Retour'}
              </button>
              <div className="flex-1 text-center">
                <h1 className="font-display font-black text-2xl italic uppercase text-white">R√®gles du Jeu</h1>
              </div>
              <div className="w-16" />
            </div>
          </div>
          <div className="flex-1 overflow-y-auto scrollbar-hide">
          <div className="max-w-3xl mx-auto p-4 md:p-8 pb-16">
            <div className="bg-gradient-to-r from-orange-600/20 to-yellow-500/10 border border-orange-500/30 rounded-2xl p-5 mb-8 text-center">
              <div className="font-display font-black text-4xl italic text-white mb-1">PREMIER √Ä {targetScore} POINTS</div>
              <p className="text-orange-300 text-sm font-bold uppercase tracking-widest">= Vainqueur de la partie</p>
            </div>
            {/* SECTION 1 : Vue d'ensemble */}
            <RuleBlock icon="üèÄ" title="Vue d'ensemble" color="#f97316" borderColor="#f97316">
              <p>
                Basket Arena est un jeu de cartes tactique pour <strong className="text-white">3 joueurs</strong> (1 humain + 2 IA).
                Chaque √©quipe poss√®de un <strong className="text-white">5 majeur</strong> sur le terrain et un <strong className="text-white">banc de 4 cartes</strong>.
                On joue en rotation : √† tour de r√¥le, une √©quipe attaque, une d√©fend, et la troisi√®me est en pause.
              </p>
            </RuleBlock>

            {/* SECTION 2 : Les cartes */}
            <RuleBlock icon="üÉè" title="Les cartes joueurs" color="#eab308" borderColor="#eab308">
              <p>Il existe <strong className="text-white">3 types de postes</strong> :</p>
              <div className="grid grid-cols-3 gap-3 my-3">
                {[
                  { poste: 'S', name: 'Small', desc: 'Arri√®re / Meneur', color: 'blue' },
                  { poste: 'M', name: 'Medium', desc: 'Ailier', color: 'orange' },
                  { poste: 'L', name: 'Large', desc: 'Pivot / Ailier fort', color: 'green' },
                ].map(p => (
                  <div key={p.poste} className="bg-slate-900 border border-slate-700 rounded-xl p-3 text-center">
                    <div className="bg-yellow-500 text-black font-black text-xl w-10 h-10 rounded-xl flex items-center justify-center mx-auto mb-2">{p.poste}</div>
                    <div className="font-bold text-white text-sm">{p.name}</div>
                    <div className="text-slate-500 text-xs">{p.desc}</div>
                  </div>
                ))}
              </div>
              <p>Chaque carte poss√®de une statistique <Tag color="orange">OFF</Tag> (offensive) et <Tag color="blue">DEF</Tag> (d√©fensive).</p>
            </RuleBlock>

            {/* SECTION 2 BIS : Synergie / Bonus d'√©quipe */}
            <RuleBlock icon="üü£" title="Synergie d'√©quipe (BONUS)" color="#a855f7" borderColor="#a855f7">
              <p>
                Quand vous alignez <strong className="text-white">au moins 2 joueurs de la m√™me √©quipe</strong> sur le terrain,
                ces joueurs re√ßoivent un bonus de synergie :
                <Tag color="orange">OFF +0.5</Tag>
                <Tag color="blue">DEF +0.5</Tag>
              </p>

              <div className="bg-slate-900/60 rounded-xl p-4 border border-slate-800 mt-3 space-y-2">
                <p className="text-slate-300 text-sm">
                  ‚úÖ Le bonus s'applique uniquement aux cartes concern√©es (celles de cette m√™me √©quipe).
                </p>
                <p className="text-slate-300 text-sm">
                  üîÑ La synergie est <strong className="text-white">calcul√©e en temps r√©el</strong> : elle appara√Æt/dispara√Æt selon les remplacements.
                </p>
                <p className="text-slate-300 text-sm">
                  üü£ Les cartes boost√©es sont rep√©rables gr√¢ce √† un <strong className="text-white">contour violet</strong>.
                </p>
              </div>

              <div className="bg-violet-500/10 border border-violet-500/30 rounded-xl p-4 mt-4">
                <div className="font-black text-violet-300 text-sm uppercase mb-2">Exemple</div>
                <p className="text-slate-300 text-sm">
                  Vous avez 2 joueurs du <strong className="text-white">Bar√ßa</strong> sur le terrain ‚Üí ces 2 joueurs passent √†
                  <Tag color="orange">OFF +0.5</Tag> et <Tag color="blue">DEF +0.5</Tag>.
                </p>
              </div>
            </RuleBlock>

            {/* SECTION 3 : Mise en place */}
            <RuleBlock icon="‚öôÔ∏è" title="Construire son √©quipe (Mise en place)" color="#3b82f6" borderColor="#3b82f6">
              <p className="font-bold text-white">Voici les √©tapes pour constituer votre 5 majeur avant le match :</p>

              <div className="space-y-3 mt-3">
                <div className="flex gap-3 bg-slate-900/60 rounded-xl p-3 border border-slate-800">
                  <div className="bg-blue-600 text-white font-black text-sm w-7 h-7 rounded-lg flex items-center justify-center flex-shrink-0">1</div>
                  <div>
                    <div className="font-bold text-white text-sm mb-1">Regarder son banc</div>
                    <div className="text-slate-400 text-sm">En bas de l'√©cran se trouve votre <strong className="text-white">banc de touche</strong> avec 9 cartes (3 S, 3 M, 3 L). Ce sont vos cartes disponibles au d√©part.</div>
                  </div>
                </div>

                <div className="flex gap-3 bg-slate-900/60 rounded-xl p-3 border border-slate-800">
                  <div className="bg-blue-600 text-white font-black text-sm w-7 h-7 rounded-lg flex items-center justify-center flex-shrink-0">2</div>
                  <div>
                    <div className="font-bold text-white text-sm mb-1">S√©lectionner un joueur</div>
                    <div className="text-slate-400 text-sm"><strong className="text-white">Cliquez sur une carte du banc</strong> pour la s√©lectionner (elle s'entoure d'un halo bleu). Elle est maintenant "en main".</div>
                  </div>
                </div>

                <div className="flex gap-3 bg-slate-900/60 rounded-xl p-3 border border-slate-800">
                  <div className="bg-blue-600 text-white font-black text-sm w-7 h-7 rounded-lg flex items-center justify-center flex-shrink-0">3</div>
                  <div>
                    <div className="font-bold text-white text-sm mb-1">Ins√©rer sur le terrain via les <span className="bg-blue-600 px-1.5 py-0.5 rounded text-white font-black">+</span></div>
                    <div className="text-slate-400 text-sm">Des boutons <strong className="text-white">+</strong> apparaissent sur la zone de terrain (entre les cartes d√©j√† plac√©es, au d√©but et √† la fin). <strong className="text-white">Cliquez sur un + </strong> pour placer votre joueur s√©lectionn√© √† cet emplacement.</div>
                  </div>
                </div>

                <div className="flex gap-3 bg-slate-900/60 rounded-xl p-3 border border-slate-800">
                  <div className="bg-blue-600 text-white font-black text-sm w-7 h-7 rounded-lg flex items-center justify-center flex-shrink-0">4</div>
                  <div>
                    <div className="font-bold text-white text-sm mb-1">Retirer un joueur du terrain</div>
                    <div className="text-slate-400 text-sm"><strong className="text-white">Cliquez sur un joueur d√©j√† sur le terrain</strong> pour l'enlever et le renvoyer sur le banc. Vous pouvez ainsi ajuster votre composition librement.</div>
                  </div>
                </div>

                <div className="flex gap-3 bg-slate-900/60 rounded-xl p-3 border border-slate-800">
                  <div className="bg-blue-600 text-white font-black text-sm w-7 h-7 rounded-lg flex items-center justify-center flex-shrink-0">5</div>
                  <div>
                    <div className="font-bold text-white text-sm mb-1">Valider quand pr√™t</div>
                    <div className="text-slate-400 text-sm">Une fois votre <strong className="text-white">5 majeur complet</strong>, cliquez sur <strong className="text-orange-400">VALIDER MON 5 MAJEUR</strong>. Les contraintes seront v√©rifi√©es.</div>
                  </div>
                </div>
              </div>

              {/* Contraintes */}
              <div className="bg-yellow-500/10 border border-yellow-500/30 rounded-xl p-4 mt-4">
                <div className="font-black text-yellow-400 text-sm uppercase mb-2">‚ö†Ô∏è Contraintes obligatoires</div>
                <ul className="space-y-1 text-sm text-slate-300">
                  <li>‚Ä¢ Exactement <strong className="text-white">5 joueurs</strong> sur le terrain</li>
                  <li>‚Ä¢ Au minimum <strong className="text-white">1 S</strong>, <strong className="text-white">1 M</strong> et <strong className="text-white">1 L</strong></li>
                  <li>‚Ä¢ Maximum <strong className="text-white">2 joueurs</strong> du m√™me poste</li>
                  <li>‚Ä¢ Ordre de gauche √† droite obligatoire : <Tag color="red">S</Tag> ‚Üí <Tag color="green">M</Tag> ‚Üí <Tag color="blue">L</Tag></li>
                </ul>
              </div>
            </RuleBlock>

            {/* SECTION 4 : D√©roulement */}
            <RuleBlock icon="üéÆ" title="D√©roulement d'un tour" color="#a855f7" borderColor="#a855f7">
              <p>Le jeu tourne entre 3 r√¥les : <Tag color="yellow">ATTAQUE</Tag> <Tag color="slate">D√âFENSE</Tag> <Tag color="slate">PAUSE</Tag></p>

              <div className="space-y-3 mt-3">
                <div className="bg-slate-900/60 rounded-xl p-3 border border-slate-800">
                  <div className="font-bold text-white text-sm mb-1">üé≤ Lancer le d√©</div>
                  <div className="text-slate-400 text-sm">Quand c'est votre tour d'attaque, <strong className="text-white">cliquez sur le logo de l'Euroleague</strong> au centre pour lancer le d√© (1 √† 6).</div>
                </div>

                <div className="bg-slate-900/60 rounded-xl p-3 border border-slate-800">
                  <div className="font-bold text-white text-sm mb-1">üéØ R√©sultat 1‚Äì5 : Duel automatique</div>
                  <div className="text-slate-400 text-sm">Le d√© d√©signe le <strong className="text-white">slot</strong> (position 1 √† 5) du d√©fenseur cibl√©. Votre joueur au m√™me slot affronte le d√©fenseur correspondant.</div>
                </div>

                <div className="bg-slate-900/60 rounded-xl p-3 border border-slate-800">
                  <div className="font-bold text-white text-sm mb-1">‚≠ê R√©sultat 6 : Choix libre</div>
                  <div className="text-slate-400 text-sm"><strong className="text-white">Vous choisissez</strong> quel d√©fenseur cibler. Cliquez sur n'importe quelle carte adverse pour d√©clencher le duel.</div>
                </div>
              </div>
            </RuleBlock>

            {/* SECTION 5 : Le Duel */}
            <RuleBlock icon="‚ö°" title="Le duel" color="#ef4444" borderColor="#ef4444">
              <p>Le jeu compare l'<Tag color="orange">OFF</Tag> de l'attaquant avec la <Tag color="blue">DEF</Tag> du d√©fenseur.</p>
              <p className="mt-2">Une probabilit√© de r√©ussite est calcul√©e : <strong className="text-white">prob = 50% + (OFF ‚àí DEF) / 18</strong>, avec un minimum de 5% et un maximum de 95%.</p>

              <div className="grid grid-cols-2 gap-3 mt-3">
                <div className="bg-green-500/10 border border-green-500/30 rounded-xl p-3 text-center">
                  <div className="text-2xl mb-1">üèÄ</div>
                  <div className="font-black text-green-400 text-sm">PANIER !</div>
                  <div className="text-slate-400 text-xs mt-1">+1 point pour l'attaquant. Le d√©fenseur cibl√© est <strong>√©limin√©</strong> du terrain.</div>
                </div>
                <div className="bg-red-500/10 border border-red-500/30 rounded-xl p-3 text-center">
                  <div className="text-2xl mb-1">‚ùå</div>
                  <div className="font-black text-red-400 text-sm">RAT√â</div>
                  <div className="text-slate-400 text-xs mt-1">Ballon perdu. L'√©quipe d√©fensive <strong>prend l'attaque</strong>.</div>
                </div>
              </div>
            </RuleBlock>

            {/* SECTION 6 : Remplacement d√©fensif */}
            <RuleBlock icon="üîÑ" title="Remplacement apr√®s un panier" color="#06b6d4" borderColor="#06b6d4">
              <p>Quand un panier est marqu√©, le d√©fenseur cibl√© quitte le terrain :</p>

              <div className="space-y-3 mt-3">
                <div className="flex gap-3 bg-slate-900/60 rounded-xl p-3 border border-slate-800">
                  <div className="text-xl flex-shrink-0">üì§</div>
                  <div className="text-slate-400 text-sm">Le joueur √©limin√© retourne dans la <strong className="text-white">pioche</strong> de son poste (S, M ou L). Il pourra revenir en jeu plus tard comme carte de remplacement.</div>
                </div>

                <div className="flex gap-3 bg-slate-900/60 rounded-xl p-3 border border-slate-800">
                  <div className="text-xl flex-shrink-0">‚è≥</div>
                  <div className="text-slate-400 text-sm"><strong className="text-white">Attention !</strong> La nouvelle carte de remplacement (pioch√©e depuis la pioche) <strong className="text-white">n'arrive sur votre banc qu'apr√®s avoir ins√©r√© un rempla√ßant</strong> dans votre 5 majeur. Elle ne se montre pas avant.</div>
                </div>

                <div className="flex gap-3 bg-slate-900/60 rounded-xl p-3 border border-slate-800">
                  <div className="text-xl flex-shrink-0">‚úÖ</div>
                  <div className="text-slate-400 text-sm">L'√©quipe d√©fensive doit <strong className="text-white">imm√©diatement remplacer</strong> le joueur sortant : cliquez sur une carte du banc, puis sur un <strong className="text-white">+</strong> pour l'ins√©rer sur le terrain.</div>
                </div>
              </div>
            </RuleBlock>

            {/* SECTION 7 : Remplacement volontaire */}
            <RuleBlock icon="üîÉ" title="Remplacement volontaire (attaquant)" color="#8b5cf6" borderColor="#8b5cf6">
              <p>Apr√®s avoir marqu√© un panier, l'attaquant peut <strong className="text-white">choisir de faire un remplacement</strong> avant son prochain tour :</p>

              <div className="space-y-3 mt-3">
                <div className="flex gap-3 bg-slate-900/60 rounded-xl p-3 border border-slate-800">
                  <div className="bg-slate-700 rounded-lg px-2 py-1 font-black text-sm text-white flex-shrink-0">1</div>
                  <div className="text-slate-400 text-sm">Cliquez sur <strong className="text-white">üîÑ Remplacer</strong> quand le bouton appara√Æt apr√®s un panier.</div>
                </div>
                <div className="flex gap-3 bg-slate-900/60 rounded-xl p-3 border border-slate-800">
                  <div className="bg-slate-700 rounded-lg px-2 py-1 font-black text-sm text-white flex-shrink-0">2</div>
                  <div className="text-slate-400 text-sm"><strong className="text-white">Cliquez sur le joueur √† sortir</strong> de votre 5 majeur (il revient sur le banc).</div>
                </div>
                <div className="flex gap-3 bg-slate-900/60 rounded-xl p-3 border border-slate-800">
                  <div className="bg-slate-700 rounded-lg px-2 py-1 font-black text-sm text-white flex-shrink-0">3</div>
                  <div className="text-slate-400 text-sm"><strong className="text-white">Cliquez sur le joueur √† faire entrer</strong> depuis le banc (il se s√©lectionne).</div>
                </div>
                <div className="flex gap-3 bg-slate-900/60 rounded-xl p-3 border border-slate-800">
                  <div className="bg-slate-700 rounded-lg px-2 py-1 font-black text-sm text-white flex-shrink-0">4</div>
                  <div className="text-slate-400 text-sm"><strong className="text-white">Cliquez sur un +</strong> sur le terrain pour ins√©rer le nouveau joueur √† la position souhait√©e. Les contraintes d'√©quipe restent obligatoires.</div>
                </div>
              </div>
            </RuleBlock>

            {/* SECTION 8 : Rotation */}
            <RuleBlock icon="üîÅ" title="Rotation des r√¥les (3 joueurs)" color="#10b981" borderColor="#10b981">
              <p>Les r√¥les tournent √† chaque panier marqu√© :</p>
              <div className="bg-slate-900/60 rounded-xl p-4 mt-3 border border-slate-800">
                <div className="flex items-center justify-center gap-4 flex-wrap">
                  <div className="text-center">
                    <div className="bg-yellow-500 text-black font-black text-xs px-3 py-1 rounded-full mb-1">ATTAQUE</div>
                    <div className="text-slate-300 text-xs">Reste attaquant<br/>tant qu'il marque</div>
                  </div>
                  <div className="text-slate-500 font-black text-2xl">‚Üí</div>
                  <div className="text-center">
                    <div className="bg-slate-500 text-white font-black text-xs px-3 py-1 rounded-full mb-1">D√âFENSE</div>
                    <div className="text-slate-300 text-xs">Si panier encaiss√© :<br/>passe en PAUSE</div>
                  </div>
                  <div className="text-slate-500 font-black text-2xl">‚Üí</div>
                  <div className="text-center">
                    <div className="bg-blue-700 text-white font-black text-xs px-3 py-1 rounded-full mb-1">PAUSE</div>
                    <div className="text-slate-300 text-xs">Devient la<br/>nouvelle D√âFENSE</div>
                  </div>
                </div>
                <div className="mt-4 text-slate-400 text-xs text-center">Si le tir est <strong className="text-red-400">rat√©</strong>, le d√©fenseur devient l'attaquant et l'attaquant devient d√©fenseur. Le joueur en pause reste en pause.</div>
              </div>
            </RuleBlock>

            <RuleBlock icon="‚ú¶" title="Mode Draft (NOUVEAU)" color="#a855f7" borderColor="#a855f7">
              <p>En mode <strong className="text-white">Draft</strong>, les 3 √©quipes choisissent leurs joueurs √† tour de r√¥le depuis un pool commun, au lieu d'une distribution al√©atoire.</p>
              <div className="bg-purple-500/10 border border-purple-500/30 rounded-xl p-4 mt-3 space-y-2">
                <p className="text-slate-300 text-sm">üêç <strong className="text-white">Ordre serpentin</strong> : VOUS ‚Üí IA1 ‚Üí IA2 ‚Üí IA2 ‚Üí IA1 ‚Üí VOUS ‚Üí ...</p>
                <p className="text-slate-300 text-sm">üÉè A chaque tour, <strong className="text-white">3 cartes</strong> sont propos√©es (1S + 1M + 1L). Vous en choisissez une.</p>
                <p className="text-slate-300 text-sm">üéØ Objectif : constituer <strong className="text-white">3S + 3M + 3L</strong> pour votre roster.</p>
                <p className="text-slate-300 text-sm">ü§ñ Les IA draftent de mani√®re <strong className="text-white">intelligente</strong> : elles √©valuent la valeur de chaque carte, les synergies potentielles et peuvent <strong className="text-white">bloquer vos picks</strong> strat√©giques.</p>
              </div>
            </RuleBlock>
            {/* SECTION 9 : IA */}
            <RuleBlock icon="ü§ñ" title="L'Intelligence Artificielle" color="#94a3b8" borderColor="#94a3b8">
              <p>
                Les <strong className="text-white">2 √©quipes IA</strong> jouent de mani√®re enti√®rement automatique,
                en prenant des d√©cisions tactiques avanc√©es.
              </p>

              <div className="bg-slate-900/60 rounded-xl p-4 border border-slate-800 mt-3 space-y-2">
                <p className="text-slate-300 text-sm">
                  üéØ En attaque, l‚ÄôIA cherche √† <strong className="text-white">maximiser ses chances r√©elles de marquer</strong>
                  en tenant compte des statistiques <Tag color="orange">OFF</Tag> / <Tag color="blue">DEF</Tag>,
                  des <strong className="text-white">bonus de synergie</strong> et des probabilit√©s de duel.
                </p>

                <p className="text-slate-300 text-sm">
                  ‚ö° Sur un <strong className="text-white">jet de d√© = 6</strong>, l‚ÄôIA choisit librement sa cible :
                  elle privil√©gie le duel le plus favorable et, √† √©galit√©, tente d‚Äô<strong className="text-white">√©liminer un joueur cl√© adverse</strong>.
                </p>

                <p className="text-slate-300 text-sm">
                  üîÑ Lors des remplacements (obligatoires ou volontaires), l‚ÄôIA √©value plusieurs compositions possibles
                  et s√©lectionne celle offrant le <strong className="text-white">meilleur √©quilibre entre attaque et d√©fense</strong>,
                  face aux <strong className="text-white">deux autres √©quipes</strong>.
                </p>

                <p className="text-slate-300 text-sm">
                  üü£ L‚ÄôIA exploite activement les <strong className="text-white">synergies d‚Äô√©quipe</strong> et les bonus associ√©s,
                  de la m√™me mani√®re qu‚Äôun joueur humain averti.
                </p>
              </div>

              <div className="bg-slate-800/60 rounded-xl p-3 mt-4 text-center">
                <p className="text-slate-400 text-xs italic">
                  L‚ÄôIA ne triche pas : elle respecte strictement les m√™mes r√®gles, contraintes et probabilit√©s que les joueurs humains.
                </p>
              </div>
            </RuleBlock>

            <button onClick={onBack} className="w-full mt-4 py-4 bg-slate-800 hover:bg-slate-700 rounded-2xl font-display font-black text-lg italic uppercase text-white flex items-center justify-center gap-2 transition-all">
              <Icons.ArrowLeft /> {backLabel || 'Retour au menu'}
            </button>
          </div>
          </div>
        </div>
      );
    };

    // ==============================
    // CARDS GALLERY SCREEN
    // ==============================
    const CardsScreen = ({ allPlayers, onBack, backLabel }) => {
      const [selectedTeam, setSelectedTeam] = useState(null);
      const [zoomedCard, setZoomedCard] = useState(null);
      const teams = [...new Set(allPlayers.map(p => String(p.TEAM_y || p.TEAM_x || '').trim()).filter(Boolean))].sort();
      const teamPlayers = selectedTeam ? allPlayers.filter(p => String(p.TEAM_y || p.TEAM_x || '').trim() === selectedTeam) : [];
      const byPoste = (poste) => teamPlayers.filter(p => String(p.Poste || '').trim().toUpperCase() === poste);

      const MiniCard = ({ player }) => (
        <div onClick={() => setZoomedCard(player)} style={{ aspectRatio: '800/1117' }}
          className="relative rounded-lg overflow-hidden bg-slate-800 shadow-xl hover:scale-105 hover:shadow-orange-500/20 transition-all cursor-pointer">
          <img src={`cartes2/${String(player.TEAM_y || player.TEAM_x || '').trim()}_card_${player.PLAYER_ID}.png`} alt={player.NAME}
            className="w-full h-full object-cover"
            onError={(e) => { e.target.onerror = null; e.target.src = `https://via.placeholder.com/400x560/1e293b/ffffff?text=${(player.NAME || '').split(',')[0]}`; }} />
        </div>
      );

      return (
        <div className="min-h-0 flex flex-col flex-1 overflow-hidden bg-slate-950">
          <div className="flex-shrink-0 bg-slate-950/95 backdrop-blur border-b border-slate-800 px-4 py-4">
            <div className="max-w-6xl mx-auto flex items-center gap-4">
              <button onClick={selectedTeam ? () => setSelectedTeam(null) : onBack} className="flex items-center gap-2 text-slate-400 hover:text-white transition-colors font-bold text-sm">
                <Icons.ArrowLeft /> {selectedTeam ? '√âquipes' : (backLabel || 'Menu')}
              </button>
              <div className="flex-1 text-center">
                <h1 className="font-display font-black text-2xl italic uppercase text-white">{selectedTeam ? selectedTeam : 'Toutes les Cartes'}</h1>
                {!selectedTeam && <p className="text-slate-500 text-xs font-bold">{allPlayers.length} cartes ¬∑ {teams.length} √©quipes</p>}
              </div>
              <div className="w-20" />
            </div>
          </div>
          <div className="flex-1 overflow-y-auto scrollbar-hide">
          {!selectedTeam ? (
            <div className="max-w-6xl mx-auto p-4 md:p-8">
              <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
                {teams.map(team => {
                  const count = allPlayers.filter(p => String(p.TEAM_y || p.TEAM_x || '').trim() === team).length;
                  return (
                    <button key={team} onClick={() => setSelectedTeam(team)}
                      className="team-card-btn bg-slate-900 border border-slate-700 hover:border-orange-500/60 rounded-2xl p-4 text-center group">
                      <div className="w-12 h-12 flex items-center justify-center mx-auto mb-3">
                        <img src={`logo/${team}.png`} alt={team} className="w-12 h-12 object-contain"
                          onError={(e) => { e.target.onerror = null; e.target.style.display='none'; e.target.nextSibling.style.display='flex'; }} />
                        <div style={{display:'none'}} className="w-12 h-12 bg-gradient-to-br from-orange-600/20 to-orange-800/20 border border-orange-500/20 rounded-xl items-center justify-center">
                          <BasketLogo size={24} className="text-orange-500" />
                        </div>
                      </div>
                      <div className="font-display font-black text-sm italic uppercase text-white leading-tight">{team}</div>
                      <div className="text-slate-500 text-xs font-bold mt-1">{count} cartes</div>
                    </button>
                  );
                })}
              </div>
            </div>
          ) : (
            <div className="max-w-6xl mx-auto p-4 md:p-8">
              <div className="grid grid-cols-3 gap-6 md:gap-8">
                {POSTES.map(poste => {
                  const cards = byPoste(poste);
                  const posteColors = {
                    S: { bg:'from-red-900/30 to-red-950/20', border:'border-red-500/30', badge:'bg-red-600' },
                    M: { bg:'from-green-900/30 to-green-950/20', border:'border-green-500/30', badge:'bg-green-600' },
                    L: { bg:'from-blue-900/30 to-blue-950/20', border:'border-blue-500/30', badge:'bg-blue-600' },
                  };
                  const c = posteColors[poste];
                  return (
                    <div key={poste} className={`rounded-2xl bg-gradient-to-b ${c.bg} border ${c.border} overflow-hidden`}>
                      <div className={`p-3 md:p-4 border-b ${c.border} flex items-center justify-center`}>
                        <div className={`${c.badge} text-white font-black text-lg md:text-xl w-10 h-10 rounded-xl flex items-center justify-center`}>{poste}</div>
                      </div>
                      <div className="p-2 md:p-3 space-y-3">
                        {cards.length === 0 ? <div className="text-slate-600 text-xs text-center py-4">Aucune carte</div> :
                          cards.map(player => <MiniCard key={player.PLAYER_ID} player={player} />)}
                      </div>
                    </div>
                  );
                })}
              </div>
            </div>
          )}
          </div>
          {zoomedCard && (
            <div className="fixed inset-0 z-[999] flex items-center justify-center p-4" onClick={() => setZoomedCard(null)}>
              <div className="absolute inset-0 bg-black/85 backdrop-blur-md" />
              <div className="relative flex flex-col items-center gap-4" onClick={e => e.stopPropagation()}>
                <div className="relative rounded-2xl overflow-hidden shadow-2xl" style={{ width: 'min(80vw, 320px)', aspectRatio: '800/1117' }}>
                  <img src={`cartes2/${String(zoomedCard.TEAM_y || zoomedCard.TEAM_x || '').trim()}_card_${zoomedCard.PLAYER_ID}.png`} alt={zoomedCard.NAME}
                    className="w-full h-full object-cover"
                    onError={(e) => { e.target.onerror = null; e.target.src = `https://via.placeholder.com/800x1117/1e293b/ffffff?text=${(zoomedCard.NAME || '').split(',')[0]}`; }} />
                </div>
                <div className="flex items-center gap-3 bg-slate-900/90 border border-slate-700 rounded-2xl px-5 py-3">
                  <span className="bg-yellow-500 text-black font-black text-sm px-2 py-0.5 rounded-lg">{zoomedCard.Poste}</span>
                  <span className="font-display font-black text-white text-lg italic uppercase">{(zoomedCard.NAME || '').split(',')[0]}</span>
                  <span className="text-orange-400 font-black text-sm">O{zoomedCard.OFF}</span>
                  <span className="text-blue-400 font-black text-sm">D{zoomedCard.DEF}</span>
                </div>
                <button onClick={() => setZoomedCard(null)} className="text-slate-400 hover:text-white text-sm font-bold uppercase tracking-widest transition-colors">‚úï Fermer</button>
              </div>
            </div>
          )}
        </div>
      );
    };

    // ==============================
    // MAIN APP
    // ==============================
    function App() {
      const [appScreen, setAppScreen] = useState('LOADING');
      const [allPlayers, setAllPlayers] = useState([]);
      const [gameState, setGameState] = useState(GAME_STATES.PREGAME);
      const [phase, setPhase] = useState(PHASES.IDLE);
      const [logs, setLogs] = useState(["Pr√™t pour le match !"]);
      const [scores, setScores] = useState([0, 0, 0]);
      const [attackerId, setAttackerId] = useState(null);
      const [defenderId, setDefenderId] = useState(null);
      const [pausedId, setPausedId] = useState(null);
      const [hands, setHands] = useState([[], [], []]);
      const [lineups, setLineups] = useState([[], [], []]);
      const [decks, setDecks] = useState({ S: [], M: [], L: [] });
      const [selectedInHand, setSelectedInHand] = useState(null);
      const [lastRoll, setLastRoll] = useState(null);
      const [targetSlot, setTargetSlot] = useState(null);
      const [shotResult, setShotResult] = useState(null);
      const [pendingDraw, setPendingDraw] = useState(null);
      const [subDoneThisTurn, setSubDoneThisTurn] = useState(false);
      const [showStatsModal, setShowStatsModal] = useState(false);
      const [stats, setStats] = useState([{}, {}, {}]);
      const [pregameError, setPregameError] = useState(null);
      const [overlay, setOverlay] = useState(null);
      const [showRoleDraw, setShowRoleDraw] = useState(false);
      const [roleDrawPhase, setRoleDrawPhase] = useState("SPIN");
      const [roleDrawResult, setRoleDrawResult] = useState(null);
      const [roleDrawTick, setRoleDrawTick] = useState(0);
      const [targetScore, setTargetScore] = useState(8);
      const [showScoreModal, setShowScoreModal] = useState(false);
      const [gameMode, setGameMode] = useState('classic'); // 'classic' | 'draft'

      // Expose targetScore for DraftScreen
      if (typeof window !== 'undefined') window._basketArenaTargetScore = targetScore;

      const playerKey = (p) => String(p?.PLAYER_ID ?? "");

      const ensurePlayerInStats = (teamId, p) => {
        if (!p) return;
        const key = playerKey(p);
        if (!key) return;
        setStats(prev => {
          if (prev[teamId]?.[key]) return prev;
          const next = [...prev];
          next[teamId] = { ...(next[teamId] || {}) };
          next[teamId][key] = { id: key, name: p.NAME || "???", poste: p.Poste || "?", off: p.OFF ?? 0, def: p.DEF ?? 0, used: 1, atkDuels: 0, atkWins: 0, defDuels: 0, defStops: 0 };
          return next;
        });
      };

      const bumpStat = (teamId, p, patchFn) => {
        if (!p) return;
        const key = playerKey(p);
        if (!key) return;
        setStats(prev => {
          const next = [...prev];
          const teamStats = { ...(next[teamId] || {}) };
          const base = teamStats[key] || { id: key, name: p.NAME || "???", poste: p.Poste || "?", off: p.OFF ?? 0, def: p.DEF ?? 0, used: 1, atkDuels: 0, atkWins: 0, defDuels: 0, defStops: 0 };
          teamStats[key] = patchFn(base);
          next[teamId] = teamStats;
          return next;
        });
      };

      const addLog = (msg) => setLogs(prev => [msg, ...prev].slice(0, 30));

      useEffect(() => {
        const winner = scores.findIndex(s => s >= targetScore);
        if (winner === -1) return;
        if (typeof window.confetti === "function") {
          const palette = { 0: ['#f97316'], 1: ['#ef4444'], 2: ['#a855f7'] };
          window.confetti({ particleCount: 150, spread: 70, origin: { y: 0.6 }, colors: palette[winner] || ['#ffffff'] });
        }
        setShowStatsModal(true);
      }, [scores, targetScore]);

      useEffect(() => {
        if (!showRoleDraw) return;
        if (roleDrawPhase !== "REVEAL") return;
        if (!roleDrawResult) return;
        const names = ["VOUS", "IA 1", "IA 2"];
        const { attacker, defender, paused } = roleDrawResult;
        setAttackerId(attacker); setDefenderId(defender); setPausedId(paused);
        addLog(`‚úÖ R√¥les : ${names[attacker]} attaque, ${names[defender]} d√©fend, ${names[paused]} en pause.`);
        const t = setTimeout(() => {
          setShowRoleDraw(false); setGameState(GAME_STATES.PLAYING);
          setPhase(PHASES.IDLE); setLastRoll(null); setTargetSlot(null);
          if (attacker === 0) addLog(`üèÄ Match commenc√© ! Tu attaques en premier. Victoire √† ${targetScore} points.`);
          else addLog(`üèÄ Match commenc√© ! ${names[attacker]} attaque en premier. Victoire √† ${targetScore} points.`);
        }, 3000);
        return () => clearTimeout(t);
      }, [showRoleDraw, roleDrawPhase, roleDrawResult, targetScore]);

      useEffect(() => {
        if (!showRoleDraw) return;
        if (roleDrawPhase !== "SPIN") return;
        const interval = setInterval(() => setRoleDrawTick(t => t + 1), 90);
        const timeout = setTimeout(() => {
          clearInterval(interval);
          const [a, d, p] = shuffle3();
          setRoleDrawResult({ attacker: a, defender: d, paused: p });
          setRoleDrawPhase("REVEAL");
        }, 2600);
        return () => { clearInterval(interval); clearTimeout(timeout); };
      }, [showRoleDraw, roleDrawPhase]);

      useEffect(() => {
        const loadAutoCsv = async () => {
          try {
            const res = await fetch(AUTO_CSV_URL, { cache: "no-store" });
            if (!res.ok) throw new Error(`HTTP ${res.status}`);
            const text = await res.text();
            const players = parsePlayersCsv(text);
            if (!players.length) throw new Error("CSV vide");
            setAllPlayers(players);
            setAppScreen('HOME');
          } catch (e) {
            setAppScreen('LOADING');
          }
        };
        loadAutoCsv();
      }, []);

      const handleManualUpload = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        const reader = new FileReader();
        reader.onload = (ev) => {
          const players = parsePlayersCsv(ev.target.result || "");
          if (!players.length) return;
          setAllPlayers(players);
          setAppScreen('HOME');
        };
        reader.readAsText(file);
      };

      const shuffle3 = () => {
        const arr = [0, 1, 2];
        for (let i = arr.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [arr[i], arr[j]] = [arr[j], arr[i]];
        }
        return arr;
      };

      // ---- START GAME (classic) ----
      const startNewGame = () => {
        if (gameMode === 'draft') {
          setAppScreen('DRAFT');
          return;
        }
        initGameFromHands(null); // classic: random
      };

      // ---- INIT GAME from hands (classic ou draft) ----
      const initGameFromHands = (draftedHands) => {
        const players = allPlayers;
        const shuffleArr = (arr) => [...arr].sort(() => Math.random() - 0.5);
        let newHands, remainingDecks;

        if (draftedHands) {
        newHands = draftedHands;

        // Grande pioche = tous les joueurs NON draft√©s
        const draftedIds = new Set(
            draftedHands.flat().map(p => String(p.PLAYER_ID))
        );

        const remaining = shuffleArr(
            players.filter(p => !draftedIds.has(String(p.PLAYER_ID)))
        );

        const s = remaining.filter(p => p.Poste?.trim().toUpperCase() === 'S');
        const m = remaining.filter(p => p.Poste?.trim().toUpperCase() === 'M');
        const l = remaining.filter(p => p.Poste?.trim().toUpperCase() === 'L');

        remainingDecks = { S: s, M: m, L: l };
        } else {
          // Mode classique
          const s = shuffleArr(players.filter(p => p.Poste?.trim().toUpperCase() === 'S'));
          const m = shuffleArr(players.filter(p => p.Poste?.trim().toUpperCase() === 'M'));
          const l = shuffleArr(players.filter(p => p.Poste?.trim().toUpperCase() === 'L'));
          newHands = [
            [...s.splice(0,3), ...m.splice(0,3), ...l.splice(0,3)],
            [...s.splice(0,3), ...m.splice(0,3), ...l.splice(0,3)],
            [...s.splice(0,3), ...m.splice(0,3), ...l.splice(0,3)],
          ];
          remainingDecks = { S: s, M: m, L: l };
        }

        setHands(newHands);
        setDecks(remainingDecks);
        setLineups([[], [], []]);
        setScores([0, 0, 0]);
        setAttackerId(null); setDefenderId(null); setPausedId(null);
        setPhase(PHASES.IDLE);
        setLastRoll(null); setTargetSlot(null); setShotResult(null); setPendingDraw(null);
        setStats([{}, {}, {}]);
        setShowStatsModal(false);
        setLogs([`Placez votre 5 majeur ! (Victoire √† ${targetScore} pts)`]);
        setGameState(GAME_STATES.PREGAME);
        setAppScreen('GAME');
      };

      // Draft complete callback
      const handleDraftComplete = (draftedHands) => {
        initGameFromHands(draftedHands);
      };

      // ---- GAME LOGIC ----
      const handleLineupClick = (idx) => {
        if (gameState === GAME_STATES.PREGAME || phase === PHASES.REMOVING_ATK) {
          const player = lineups[0][idx];
          const newLineup = [...lineups[0]]; newLineup.splice(idx, 1);
          const newHands = [...hands]; newHands[0] = [...newHands[0], player];
          const newLineups = [...lineups]; newLineups[0] = newLineup;
          setLineups(newLineups); setHands(newHands);
          if (phase === PHASES.REMOVING_ATK) { setPhase(PHASES.PLACING_REPLACEMENT); addLog("Joueur sorti. Choisissez un rempla√ßant."); }
        }
      };

      const handleInsertion = (idx) => {
        if (selectedInHand === null) return;
        const card = hands[0][selectedInHand];
        ensurePlayerInStats(0, card);
        const current = lineups[0];
        if (current.filter(p => p.Poste === card.Poste).length >= 2) return addLog(`‚ö† Max 2 ${card.Poste} sur le terrain.`);
        const newLineup = [...current]; newLineup.splice(idx, 0, card);
        const orderMap = { 'S': 1, 'M': 2, 'L': 3 };
        for (let i = 0; i < newLineup.length - 1; i++) {
          if (orderMap[newLineup[i].Poste] > orderMap[newLineup[i+1].Poste]) return addLog("‚ö† Ordre S ‚Üí M ‚Üí L obligatoire !");
        }
        if ((phase === PHASES.PLACING_REPLACEMENT || phase === PHASES.REPLACING_DEF)) {
          const hasAll = POSTES.every(pos => newLineup.some(p => p.Poste === pos));
          if (!hasAll && newLineup.length === 5) return addLog("‚ö† Min 1 S, 1 M et 1 L requis.");
        }
        const newLineups = [...lineups]; newLineups[0] = newLineup;
        const newHands = [...hands]; newHands[0] = newHands[0].filter((_, i) => i !== selectedInHand);
        if (pendingDraw && pendingDraw.playerId === 0) {
          const deck = decks[pendingDraw.poste];
          if (deck.length > 0) { newHands[0].push(deck[0]); setDecks(prev => ({ ...prev, [pendingDraw.poste]: prev[pendingDraw.poste].slice(1) })); }
          setPendingDraw(null);
        }
        setHands(newHands); setLineups(newLineups); setSelectedInHand(null);
        if (phase === PHASES.REPLACING_DEF || phase === PHASES.PLACING_REPLACEMENT) { setPhase(PHASES.ATK_SUB_DECISION); addLog("Remplacement effectu√©."); setSubDoneThisTurn(true); }
      };

      const beginRoleDraw = () => {
        setGameState(GAME_STATES.KICKOFF);
        setPhase(PHASES.IDLE); setLastRoll(null); setTargetSlot(null);
        setRoleDrawPhase("SPIN"); setRoleDrawResult(null); setRoleDrawTick(0);
        setShowRoleDraw(true);
        addLog("üé≤ Tirage au sort des r√¥les...");
      };

      const validatePregame = () => {
        const count = lineups[0].length;
        if (count === 0) return setPregameError({ title: "√âquipe vide !", body: "Vous n'avez plac√© aucun joueur sur le terrain. Cliquez sur une carte du banc pour la s√©lectionner, puis sur un + pour la placer." });
        if (count < 5) return setPregameError({ title: `Il manque ${5 - count} joueur${5 - count > 1 ? 's' : ''} !`, body: `Votre 5 majeur doit contenir exactement 5 joueurs. Vous en avez ${count} pour l'instant. S√©lectionnez des joueurs du banc et placez-les sur le terrain.` });
        const missingPostes = POSTES.filter(pos => !lineups[0].some(p => p.Poste === pos));
        if (missingPostes.length > 0) return setPregameError({ title: "Composition invalide !", body: `Poste(s) manquant(s) : ${missingPostes.join(', ')}.` });
        const newLineups = [...lineups]; const newHands = [...hands];
        [1, 2].forEach(idx => {
          const h = [...newHands[idx]].sort((a,b) => (b.OFF + b.DEF) - (a.OFF + a.DEF));
          const aiL = [];
          POSTES.forEach(p => { const b = h.find(c => c.Poste === p); if(b) { aiL.push(b); h.splice(h.indexOf(b), 1); } });
          while(aiL.length < 5) { const n = h.find(c => aiL.filter(x => x.Poste === c.Poste).length < 2); if(n) { aiL.push(n); h.splice(h.indexOf(n), 1); } else break; }
          const oMap = { 'S': 1, 'M': 2, 'L': 3 };
          aiL.sort((a,b) => oMap[a.Poste] - oMap[b.Poste]);
          newLineups[idx] = aiL; newHands[idx] = h;
        });
        setLineups(newLineups); setHands(newHands);
        addLog("‚úÖ √âquipes valid√©es. Pr√©paration du match...");
        beginRoleDraw();
        [0,1,2].forEach(tid => newLineups[tid].forEach(p => ensurePlayerInStats(tid, p)));
      };

      const executeDuel = useCallback((slot) => {
        setTargetSlot(slot); setPhase(PHASES.DUEL);
        const atkP = lineups[attackerId][slot];
        const defP = lineups[defenderId][slot];
        ensurePlayerInStats(attackerId, atkP); ensurePlayerInStats(defenderId, defP);
        bumpStat(attackerId, atkP, s => ({ ...s, atkDuels: s.atkDuels + 1 }));
        bumpStat(defenderId, defP, s => ({ ...s, defDuels: s.defDuels + 1 }));
        const atkSynergy = computeSynergyTeams(lineups[attackerId]);
        const defSynergy = computeSynergyTeams(lineups[defenderId]);
        const atkOff = effectiveOFF(atkP, atkSynergy);
        const defDef = effectiveDEF(defP, defSynergy);
        const prob = Math.min(Math.max(0.5 + (atkOff - defDef) / 18, 0.05), 0.95);
        const win = Math.random() < prob;
        setTimeout(() => {
          setShotResult({ success: win, side: attackerId });
          setTimeout(() => {
            setShotResult(null);
            if (win) {
              addLog(`üèÄ PANIER ! ${atkP.NAME.split(',')[0]} marque.`);
              bumpStat(attackerId, atkP, s => ({ ...s, atkWins: s.atkWins + 1 }));
              const newScores = [...scores]; newScores[attackerId]++; setScores(newScores);
              if (newScores[attackerId] >= targetScore) return setGameState(GAME_STATES.GAMEOVER);
              const lost = lineups[defenderId][slot];
              const nLineups = [...lineups]; nLineups[defenderId].splice(slot, 1); setLineups(nLineups);
              setDecks(prev => ({ ...prev, [lost.Poste]: [...prev[lost.Poste], lost] }));
              setPendingDraw({ playerId: defenderId, poste: lost.Poste });
              setTargetSlot(null); setPhase(PHASES.REPLACING_DEF); setSubDoneThisTurn(false);
              const oldDef = defenderId; const oldPause = pausedId;
              setDefenderId(oldPause); setPausedId(oldDef);
              addLog(`üîÑ Prochaine cible : ${["VOUS","IA 1","IA 2"][oldPause]}`);
            } else {
              addLog(`‚ùå BLOQU√â ! D√©fense de ${defP.NAME.split(',')[0]}.`);
              bumpStat(defenderId, defP, s => ({ ...s, defStops: s.defStops + 1 }));
              setAttackerId(defenderId); setDefenderId(attackerId);
              setPhase(PHASES.IDLE); setLastRoll(null); setTargetSlot(null);
            }
          }, 1000);
        }, 1200);
      }, [attackerId, defenderId, pausedId, lineups, scores, targetScore]);

      const rollDie = () => {
        if (gameState !== GAME_STATES.PLAYING) return;
        if (attackerId === null) return;
        if (phase !== PHASES.IDLE || attackerId !== 0) return;
        const roll = Math.floor(Math.random() * 6) + 1;
        setLastRoll(roll); setPhase(PHASES.ROLLING);
        setTimeout(() => {
          if (roll <= 5) executeDuel(roll - 1);
          else { setPhase(PHASES.CHOOSING_TARGET); addLog("üéØ CHOIX LIBRE !"); }
        }, 1000);
      };

      useEffect(() => {
        if (gameState !== GAME_STATES.PLAYING) return;
        if (attackerId !== 0 && phase === PHASES.IDLE) {
          const t = setTimeout(() => {
            const roll = Math.floor(Math.random() * 6) + 1;
            setLastRoll(roll); setPhase(PHASES.ROLLING);
            setTimeout(() => {
              let slot = roll <= 5 ? roll - 1 : 0;
              if (roll === 6) {
                const atkL = lineups[attackerId]; const defL = lineups[defenderId];
                let bestProb = -1; let candidates = [];
                atkL.forEach((p, i) => {
                  const pr = probScore(p, atkL, defL[i], defL);
                  if (pr > bestProb + 1e-6) { bestProb = pr; candidates = [i]; }
                  else if (Math.abs(pr - bestProb) < 1e-6) candidates.push(i);
                });
                slot = candidates.sort((a, b) => ((defL[b]?.OFF??0)+(defL[b]?.DEF??0)) - ((defL[a]?.OFF??0)+(defL[a]?.DEF??0)))[0];
              }
              executeDuel(slot);
            }, 1000);
          }, 1500);
          return () => clearTimeout(t);
        }
        if (phase === PHASES.REPLACING_DEF || phase === PHASES.ATK_SUB_DECISION) {
          const activeReplacing = phase === PHASES.REPLACING_DEF ? pausedId : attackerId;
          if (activeReplacing !== 0) {
            const t = setTimeout(() => {
              const h = [...hands[activeReplacing]]; const l = [...lineups[activeReplacing]];
              if (phase === PHASES.REPLACING_DEF) {
                const team = activeReplacing;
                const oppIds = [0, 1, 2].filter(x => x !== team);
                const oppA = lineups[oppIds[0]]; const oppB = lineups[oppIds[1]];
                let best = null; let bestU = -1e9;
                for (let ci = 0; ci < h.length; ci++) {
                  const card = h[ci];
                  if (l.filter(x => x.Poste === card.Poste).length >= 2) continue;
                  const candidates = generateInsertions(l, card);
                  for (const cand of candidates) {
                    const u = lineupUtility(cand, oppA, oppB, { off: 0.55, def: 0.45 });
                    if (u > bestU) { bestU = u; best = { ci, lineup: cand }; }
                  }
                }
                if (best) {
                  ensurePlayerInStats(team, h[best.ci]);
                  const newHands = h.filter((_, i) => i !== best.ci);
                  if (pendingDraw && pendingDraw.playerId === team) {
                    const d = decks[pendingDraw.poste];
                    if (d.length) { newHands.push(d[0]); setDecks(v => ({ ...v, [pendingDraw.poste]: v[pendingDraw.poste].slice(1) })); }
                    setPendingDraw(null);
                  }
                  const nl = [...lineups]; nl[team] = best.lineup;
                  const nh = [...hands]; nh[team] = newHands;
                  setLineups(nl); setHands(nh);
                }
                setPhase(PHASES.ATK_SUB_DECISION);
              } else {
                setPhase(PHASES.IDLE); setLastRoll(null); setTargetSlot(null);
              }
            }, 1000);
            return () => clearTimeout(t);
          }
        }
      }, [phase, attackerId, defenderId, pausedId, gameState, lineups, hands, decks, pendingDraw, executeDuel]);

      const getUserBoardStyle = () => {
        if (attackerId === 0) return 'ring-4 ring-yellow-500 border-yellow-500/50 bg-gradient-to-br from-yellow-900/40 via-yellow-900/20 to-black glow-gold';
        if (defenderId === 0) return 'ring-4 ring-slate-400 border-slate-400/50 bg-gradient-to-br from-slate-700/40 via-slate-800/20 to-black glow-silver';
        return 'border-blue-500/20 bg-blue-900/10';
      };

      const currentAtkPlayer = (phase === PHASES.DUEL || phase === PHASES.ROLLING) && targetSlot !== null ? lineups[attackerId]?.[targetSlot] : null;
      const currentDefPlayer = (phase === PHASES.DUEL || phase === PHASES.ROLLING) && targetSlot !== null ? lineups[defenderId]?.[targetSlot] : null;
      const currentAtkSynergy = computeSynergyTeams(lineups[attackerId] || []);
      const currentDefSynergy = computeSynergyTeams(lineups[defenderId] || []);

      // ====== SCREEN ROUTING ======
      if (appScreen === 'LOADING') {
        return (
          <div className="home-bg min-h-screen flex flex-col items-center justify-center p-6">
            <div className="text-center mb-8">
              <div className="w-20 h-20 bg-orange-600/20 rounded-2xl flex items-center justify-center mx-auto mb-4 pulse-glow">
                <BasketLogo size={40} className="text-orange-500" />
              </div>
              <h1 className="font-display text-5xl font-black italic uppercase text-white">BASKET ARENA</h1>
              <p className="text-slate-500 text-sm mt-2">Chargement des donn√©es...</p>
            </div>
            <div className="bg-slate-900/80 border border-slate-800 rounded-2xl p-6 max-w-sm w-full text-center">
              <p className="text-slate-400 text-sm mb-4">Fichier attendu : <span className="font-mono text-slate-200 text-xs">{AUTO_CSV_URL}</span></p>
              <label className="bg-orange-600 hover:bg-orange-500 text-white px-6 py-3 rounded-xl font-black cursor-pointer shadow-xl transition-all inline-block text-sm uppercase">
                Importer CSV <input type="file" accept=".csv" onChange={handleManualUpload} className="hidden" />
              </label>
            </div>
          </div>
        );
      }

      if (appScreen === 'HOME') {
        return (
          <HomeScreen
            onStartGame={startNewGame}
            onRules={() => setAppScreen('RULES')}
            onCards={() => setAppScreen('CARDS')}
            targetScore={targetScore}
            setTargetScore={setTargetScore}
            showScoreModal={showScoreModal}
            setShowScoreModal={setShowScoreModal}
            gameMode={gameMode}
            setGameMode={setGameMode}
          />
        );
      }

      if (appScreen === 'RULES') {
        return <div className="min-h-screen flex flex-col bg-slate-950"><RulesScreen targetScore={targetScore} onBack={() => setAppScreen('HOME')} /></div>;
      }

      if (appScreen === 'CARDS') {
        return <div className="min-h-screen flex flex-col bg-slate-950"><CardsScreen allPlayers={allPlayers} onBack={() => setAppScreen('HOME')} /></div>;
      }

      // ====== DRAFT SCREEN ======
      if (appScreen === 'DRAFT') {
        return (
          <DraftScreen
            allPlayers={allPlayers}
            onDraftComplete={handleDraftComplete}
            onBack={() => setAppScreen('HOME')}
          />
        );
      }

      // ====== GAME SCREEN ======
      return (
        <>
        {overlay === 'RULES' && (
          <OverlayModal onClose={() => setOverlay(null)}>
            <RulesScreen targetScore={targetScore} onBack={() => setOverlay(null)} backLabel="Fermer" />
          </OverlayModal>
        )}
        {overlay === 'CARDS' && (
          <OverlayModal onClose={() => setOverlay(null)}>
            <CardsScreen allPlayers={allPlayers} onBack={() => setOverlay(null)} backLabel="Fermer" />
          </OverlayModal>
        )}
        <div className="min-h-screen p-4 md:p-6 overflow-x-hidden">
          <header className="max-w-[95%] mx-auto flex flex-col md:flex-row justify-between items-center mb-8 gap-6">
            <div className="flex items-center gap-4">
              <button onClick={() => setAppScreen('HOME')} className="bg-slate-800 hover:bg-slate-700 p-2.5 rounded-xl transition-all flex items-center gap-2 text-slate-400 hover:text-white text-sm font-bold">
                <Icons.ArrowLeft />
              </button>
              <div className="p-3 rounded-2xl flex items-center justify-center bg-gradient-to-br from-black via-slate-900 to-black border border-orange-500/60 shadow-[0_0_30px_rgba(249,115,22,0.45)]">
                <BasketLogo size={28} className="object-contain drop-shadow-[0_2px_10px_rgba(0,0,0,0.7)]" />
              </div>
              <div>
                <div className="flex items-center gap-2">
                  <h1 className="font-display text-2xl font-black italic uppercase leading-none tracking-tighter text-white">Basket Arena</h1>
                  {gameMode === 'draft' && (
                    <span className="px-2 py-0.5 rounded-lg bg-purple-700 text-purple-100 font-black text-[9px] uppercase tracking-widest">DRAFT</span>
                  )}
                </div>
                <p className="text-[10px] text-slate-500 font-bold uppercase tracking-widest mt-1">
                  √âdition Tactique 3 Joueurs ¬∑ Victoire √† {targetScore} pts
                </p>
              </div>
            </div>
            <div className="flex bg-slate-900/80 border border-slate-800 rounded-3xl p-1 items-center shadow-2xl">
              <ScoreBox label="VOUS" score={scores[0]} active={attackerId === 0} isDef={defenderId === 0} />
              <div className="w-px h-8 bg-slate-800 mx-2"></div>
              <ScoreBox label="IA 1" score={scores[1]} active={attackerId === 1} isDef={defenderId === 1} />
              <div className="w-px h-8 bg-slate-800 mx-2"></div>
              <ScoreBox label="IA 2" score={scores[2]} active={attackerId === 2} isDef={defenderId === 2} />
            </div>
          </header>

          <main className="max-w-[95%] mx-auto grid grid-cols-1 lg:grid-cols-12 gap-6">
            <div className="lg:col-span-9 space-y-6">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <AITeamZone teamId={1} label="IA 1" lineup={lineups[1]} isAttacking={attackerId===1} isDefending={defenderId===1} targetSlot={targetSlot} isDuelActive={phase===PHASES.DUEL} onSlotClick={(i) => phase===PHASES.CHOOSING_TARGET && defenderId===1 && executeDuel(i)} />
                <AITeamZone teamId={2} label="IA 2" lineup={lineups[2]} isAttacking={attackerId===2} isDefending={defenderId===2} targetSlot={targetSlot} isDuelActive={phase===PHASES.DUEL} onSlotClick={(i) => phase===PHASES.CHOOSING_TARGET && defenderId===2 && executeDuel(i)} />
              </div>

              <div className="bg-slate-900/40 border border-slate-800 rounded-[2.5rem] p-8 min-h-[160px] flex flex-col items-center justify-center relative shadow-inner">
                {gameState === GAME_STATES.PREGAME ? (
                  <button onClick={validatePregame} className="bg-orange-600 hover:bg-orange-500 text-white px-12 py-4 rounded-2xl font-display font-black text-lg shadow-2xl transition-all flex items-center gap-2 hover:scale-105 italic uppercase">
                    VALIDER MON 5 MAJEUR <Icons.Plus />
                  </button>
                ) : gameState === GAME_STATES.GAMEOVER ? (
                  <div className="text-center">
                    <h2 className="font-display text-4xl font-black italic uppercase mb-4 text-white">Match Termin√©</h2>
                    <div className="flex flex-col md:flex-row gap-3 justify-center">
                      <button onClick={() => setShowStatsModal(true)} className="bg-blue-600 hover:bg-blue-500 text-white px-8 py-2 rounded-lg font-black uppercase">R√©sultats & stats</button>
                      <button onClick={() => initGameFromHands(null)} className="bg-white text-black px-8 py-2 rounded-lg font-bold uppercase">REJOUER</button>
                      <button onClick={() => setAppScreen('HOME')} className="bg-slate-700 text-white px-8 py-2 rounded-lg font-bold uppercase">MENU</button>
                    </div>
                  </div>
                ) : (
                  <div className="w-full flex flex-col items-center gap-6">
                    <div className="flex items-center justify-center gap-4 md:gap-16 w-full max-w-2xl">
                      <div className="w-24 md:w-32 flex justify-end">
                        {currentAtkPlayer && (
                          <div className="animate-pop-stat flex flex-col items-end">
                            <span className="text-[10px] font-black text-yellow-500 uppercase tracking-widest mb-1">ATTAQUE</span>
                            <div className="bg-gradient-to-br from-yellow-400 to-yellow-600 text-black w-14 h-14 md:w-16 md:h-16 rounded-2xl flex items-center justify-center font-black text-2xl md:text-3xl shadow-[0_0_20px_rgba(234,179,8,0.4)] border-2 border-yellow-200/50">
                              {effectiveOFF(currentAtkPlayer, currentAtkSynergy)}
                            </div>
                          </div>
                        )}
                      </div>
                      <div className="relative z-10">
                        <button
                          onClick={rollDie}
                          disabled={phase !== PHASES.IDLE || attackerId !== 0}
                          className={`w-16 h-16 md:w-20 md:h-20 rounded-full flex items-center justify-center transition-all duration-300 border-4 shadow-2xl ${attackerId === 0 && phase === PHASES.IDLE ? 'bg-gradient-to-br from-black via-slate-900 to-black border-orange-500/70 hover:scale-110 shadow-[0_0_30px_rgba(249,115,22,0.45)]' : 'bg-slate-900 border-slate-700 opacity-60'}`}
                        >
                          {lastRoll ? (
                            <span className="text-3xl md:text-4xl font-black text-white">{lastRoll}</span>
                          ) : (
                            <BasketLogo size={40} className={`object-contain drop-shadow-[0_2px_10px_rgba(0,0,0,0.7)] ${phase === PHASES.ROLLING ? 'animate-roll' : ''}`} />
                          )}
                        </button>
                        {shotResult && (
                          <div className="absolute -top-10 left-1/2 -translate-x-1/2 whitespace-nowrap">
                            <div className={`px-4 py-1.5 rounded-full text-white font-black italic uppercase text-xs shadow-2xl ${shotResult.success ? 'bg-green-600' : 'bg-red-600'}`}>
                              {shotResult.success ? "PANIER !" : "RAT√â"}
                            </div>
                          </div>
                        )}
                      </div>
                      <div className="w-24 md:w-32 flex justify-start">
                        {currentDefPlayer && (
                          <div className="animate-pop-stat flex flex-col items-start">
                            <span className="text-[10px] font-black text-slate-400 uppercase tracking-widest mb-1">D√âFENSE</span>
                            <div className="bg-gradient-to-br from-slate-300 to-slate-500 text-black w-14 h-14 md:w-16 md:h-16 rounded-2xl flex items-center justify-center font-black text-2xl md:text-3xl shadow-[0_0_20px_rgba(148,163,184,0.4)] border-2 border-slate-100/50">
                              {effectiveDEF(currentDefPlayer, currentDefSynergy)}
                            </div>
                          </div>
                        )}
                      </div>
                    </div>
                    <StatusLine phase={phase} attackerId={attackerId} defenderId={defenderId} subDoneThisTurn={subDoneThisTurn} onSkip={() => { setPhase(PHASES.IDLE); setLastRoll(null); setTargetSlot(null); }} onSub={() => setPhase(PHASES.REMOVING_ATK)} />
                  </div>
                )}
              </div>

              <div data-team-id={0} className={`p-4 md:p-6 rounded-[2.5rem] border team-zone-transition relative shadow-lg ${getUserBoardStyle()}`}>
                <div className={`absolute -top-3 left-8 text-white text-[10px] font-black px-4 py-1 rounded-full uppercase tracking-widest shadow-lg ${attackerId === null ? 'bg-slate-600' : attackerId === 0 ? 'bg-yellow-600' : defenderId === 0 ? 'bg-slate-500' : 'bg-blue-600'}`}>
                  {attackerId === null ? "üß© COMPOSITION D'√âQUIPE" : attackerId === 0 ? "üî• VOUS ATTAQUEZ" : defenderId === 0 ? "üõ°Ô∏è VOUS D√âFENDEZ" : "‚è∏Ô∏è VOUS (EN PAUSE)"}
                </div>
                <div className="flex justify-center items-center gap-1.5 md:gap-2 min-h-[140px] md:min-h-[220px] w-full px-2 py-2">
                  {(() => {
                    const showZones = gameState === GAME_STATES.PREGAME || phase === PHASES.PLACING_REPLACEMENT || (phase === PHASES.REPLACING_DEF && pausedId === 0);
                    const canInsertAt = (insertIdx) => {
                      if (!showZones || selectedInHand === null) return false;
                      const card = hands[0][selectedInHand];
                      const orderMap = { 'S': 1, 'M': 2, 'L': 3 };
                      const test = [...lineups[0]]; test.splice(insertIdx, 0, card);
                      for (let k = 0; k < test.length - 1; k++) { if (orderMap[test[k].Poste] > orderMap[test[k+1].Poste]) return false; }
                      return true;
                    };
                    return canInsertAt(0) ? <DropZone onClick={() => handleInsertion(0)} /> : null;
                  })()}
                  {(() => {
                    const userSynergy = computeSynergyTeams(lineups[0]);
                    return lineups[0].map((p, i) => (
                      <React.Fragment key={i}>
                        <PlayerCard
                          player={p} synergyTeams={userSynergy}
                          isTarget={defenderId === 0 && targetSlot === i}
                          isAttacker={attackerId === 0 && targetSlot === i && (phase === PHASES.ROLLING || phase === PHASES.DUEL)}
                          isJumping={phase === PHASES.DUEL && targetSlot === i && (attackerId === 0 || defenderId === 0)}
                          onClick={() => handleLineupClick(i)}
                          disabled={gameState !== GAME_STATES.PREGAME && phase !== PHASES.REMOVING_ATK}
                        />
                        {(() => {
                          const showZones = gameState === GAME_STATES.PREGAME || phase === PHASES.PLACING_REPLACEMENT || (phase === PHASES.REPLACING_DEF && pausedId === 0);
                          const canInsertAt = (insertIdx) => {
                            if (!showZones || selectedInHand === null) return false;
                            const card = hands[0][selectedInHand];
                            const orderMap = { 'S': 1, 'M': 2, 'L': 3 };
                            const test = [...lineups[0]]; test.splice(insertIdx, 0, card);
                            for (let k = 0; k < test.length - 1; k++) { if (orderMap[test[k].Poste] > orderMap[test[k+1].Poste]) return false; }
                            return true;
                          };
                          return canInsertAt(i + 1) ? <DropZone onClick={() => handleInsertion(i + 1)} /> : null;
                        })()}
                      </React.Fragment>
                    ));
                  })()}
                </div>
              </div>

              <div className="bg-slate-900/60 rounded-[2rem] p-4 border border-slate-800 shadow-xl">
                <h3 className="text-[11px] font-black uppercase text-slate-500 flex items-center gap-2 mb-4 md:mb-6"><Icons.UserPlus /> Banc de touche</h3>
                <div className="flex gap-2 md:gap-4 overflow-x-auto pb-2 scrollbar-hide px-2">
                  {(() => {
                    const currentLineup = lineups[0];
                    const isSelectingMode = gameState === GAME_STATES.PREGAME || phase === PHASES.PLACING_REPLACEMENT || (phase === PHASES.REPLACING_DEF && pausedId === 0);
                    const isBenchCardPlayable = (card) => {
                      if (!isSelectingMode) return true;
                      if (currentLineup.length >= 5) return false;
                      const posOnField = currentLineup.filter(p => p.Poste === card.Poste).length;
                      if (posOnField >= 2) return false;
                      const afterLineup = [...currentLineup, card];
                      const slotsLeft = 5 - afterLineup.length;
                      const remainingBench = hands[0].filter((_, bi) => hands[0][bi] !== card);
                      const missingPostes = POSTES.filter(pos => {
                        const onField = afterLineup.filter(p => p.Poste === pos).length;
                        if (onField > 0) return false;
                        return remainingBench.filter(p => p.Poste === pos).length === 0;
                      });
                      if (missingPostes.length > 0) return false;
                      const uncoveredPostes = POSTES.filter(pos => afterLineup.filter(p => p.Poste === pos).length === 0);
                      if (uncoveredPostes.length > slotsLeft) return false;
                      return true;
                    };
                    return hands[0].map((p, i) => (
                      <PlayerCard key={i} player={p} size="sm" selected={selectedInHand === i}
                        grayed={isSelectingMode && !isBenchCardPlayable(p)}
                        onClick={() => {
                          if (!isBenchCardPlayable(p)) return;
                          if ((phase === PHASES.REPLACING_DEF && pausedId === 0) || phase === PHASES.PLACING_REPLACEMENT) { setSelectedInHand(i); setPhase(PHASES.PLACING_REPLACEMENT); }
                          else { setSelectedInHand(i === selectedInHand ? null : i); }
                        }}
                      />
                    ));
                  })()}
                </div>
              </div>
            </div>

            <aside className="lg:col-span-3 flex flex-col gap-6">
              <div className="bg-black/50 backdrop-blur rounded-3xl p-5 border border-slate-800 h-[300px] overflow-hidden flex flex-col shadow-2xl">
                <div className="flex items-center gap-2 mb-4 text-[11px] font-black text-slate-500 uppercase tracking-widest"><Icons.History /> Chronologie</div>
                <div className="overflow-y-auto flex-1 space-y-2 pr-2 scrollbar-hide">
                  {logs.map((log, i) => (
                    <div key={i} className={`p-3 rounded-xl text-[10px] font-medium leading-snug ${log.includes('üèÄ') ? 'bg-orange-500/10 text-orange-400' : 'bg-slate-800/40 text-slate-400'}`}>{log}</div>
                  ))}
                </div>
              </div>
              <div className="bg-slate-900/50 rounded-3xl p-5 border border-slate-800 flex flex-col gap-3">
                <h4 className="font-display font-black text-slate-300 italic uppercase text-lg">Navigation</h4>
                <button onClick={() => setOverlay('RULES')} className="w-full py-3 bg-slate-800 hover:bg-slate-700 rounded-xl text-slate-200 font-bold text-sm flex items-center justify-center gap-2 transition-all">
                  <Icons.Book /> R√®gles du jeu
                </button>
                <button onClick={() => setOverlay('CARDS')} className="w-full py-3 bg-slate-800 hover:bg-slate-700 rounded-xl text-slate-200 font-bold text-sm flex items-center justify-center gap-2 transition-all">
                  <Icons.Cards /> Voir les cartes
                </button>
                <button onClick={() => setAppScreen('HOME')} className="w-full py-3 bg-slate-800 hover:bg-slate-700 rounded-xl text-slate-400 font-bold text-sm flex items-center justify-center gap-2 transition-all">
                  ‚Üê Menu principal
                </button>
              </div>
            </aside>
          </main>

          <RoleDrawModal open={showRoleDraw} tick={roleDrawTick} phase={roleDrawPhase} result={roleDrawResult}
            onSkip={() => { const [a, d, p] = shuffle3(); setRoleDrawResult({ attacker: a, defender: d, paused: p }); setRoleDrawPhase("REVEAL"); }} />
          <StatsModal open={showStatsModal} onClose={() => setShowStatsModal(false)} stats={stats} scores={scores}
            onReplay={() => initGameFromHands(null)} onMenu={() => { setAppScreen('HOME'); setShowStatsModal(false); }} />

          {pregameError && (
            <div className="fixed inset-0 z-[999] flex items-center justify-center p-4">
              <div onClick={() => setPregameError(null)} className="absolute inset-0 bg-black/70 backdrop-blur-sm" />
              <div className="relative bg-slate-900 border border-red-500/40 rounded-3xl p-8 max-w-sm w-full shadow-2xl text-center">
                <div className="w-14 h-14 bg-red-500/20 rounded-2xl flex items-center justify-center mx-auto mb-4"><span className="text-3xl">‚ö†Ô∏è</span></div>
                <h3 className="font-display font-black text-2xl italic uppercase text-white mb-3">{pregameError.title}</h3>
                <p className="text-slate-400 text-sm leading-relaxed mb-6">{pregameError.body}</p>
                <button onClick={() => setPregameError(null)} className="w-full py-3 bg-orange-600 hover:bg-orange-500 rounded-xl font-black uppercase text-white transition-all">OK</button>
              </div>
            </div>
          )}
        </div>
        </>
      );
    }

    // ---- SMALL COMPONENTS ----
    const ScoreBox = ({ label, score, active, isDef }) => {
      const activeStyle = active ? 'ring-2 ring-yellow-500 bg-yellow-500/20 shadow-[0_0_15px_rgba(234,179,8,0.3)]' : isDef ? 'ring-2 ring-slate-400 bg-slate-400/20' : '';
      const colorText = active ? 'text-yellow-400' : isDef ? 'text-slate-200' : 'text-slate-600';
      return (
        <div className={`px-4 md:px-5 py-2 text-center rounded-2xl transition-all duration-500 ${activeStyle}`}>
          <p className="text-[8px] font-black uppercase tracking-widest text-slate-500">{label}</p>
          <p className={`text-xl md:text-2xl font-black ${colorText}`}>{score}</p>
        </div>
      );
    };

    const AITeamZone = ({ label, lineup, isAttacking, isDefending, targetSlot, isDuelActive, onSlotClick, teamId }) => {
      const ring = isAttacking ? 'ring-4 ring-yellow-500 border-yellow-500/50 bg-gradient-to-br from-yellow-900/40 via-yellow-900/20 to-black glow-gold'
        : isDefending ? 'ring-4 ring-slate-400 border-slate-400/50 bg-gradient-to-br from-slate-700/40 via-slate-800/20 to-black glow-silver'
        : 'border-slate-800 bg-slate-900/20';
      const synergyTeams = computeSynergyTeams(lineup);
      return (
        <div data-team-id={teamId} className={`p-3 md:p-4 rounded-3xl border team-zone-transition relative shadow-lg ${ring} w-full min-w-0`}>
          <div className={`absolute -top-2.5 left-6 text-white text-[9px] font-black px-3 py-1 rounded-full shadow-lg uppercase whitespace-nowrap ${isAttacking ? 'bg-yellow-600' : isDefending ? 'bg-slate-500' : 'bg-slate-800'}`}>
            {isAttacking ? `üî• ${label} ATTAQUE` : isDefending ? `üõ°Ô∏è ${label} D√âFEND` : label}
          </div>
          <div className="flex justify-center items-center gap-1 md:gap-2 min-h-[120px] md:min-h-[220px] w-full py-2">
            {lineup.map((p, i) => (
              <PlayerCard key={i} player={p} size="sm" synergyTeams={synergyTeams}
                isTarget={isDefending && targetSlot === i} isAttacker={isAttacking && targetSlot === i}
                isJumping={isDuelActive && targetSlot === i && (isAttacking || isDefending)}
                canBeTargeted={isDefending && !targetSlot} onClick={() => onSlotClick(i)} />
            ))}
          </div>
        </div>
      );
    };

    const StatusLine = ({ phase, attackerId, defenderId, onSkip, onSub, subDoneThisTurn }) => {
      const names = ["VOUS", "IA 1", "IA 2"];
      if (phase === PHASES.ATK_SUB_DECISION && attackerId === 0) {
        return (
          <div className="flex gap-4">
            {!subDoneThisTurn && <button onClick={onSub} className="bg-blue-600 px-6 py-2 rounded-xl text-[10px] font-black uppercase hover:bg-blue-500 transition-all shadow-lg">üîÑ Remplacer</button>}
            <button onClick={onSkip} className="bg-slate-800 px-6 py-2 rounded-xl text-[10px] font-black uppercase hover:bg-slate-700 transition-all">üèÄ Continuer</button>
          </div>
        );
      }
      let txt = "";
      if (phase === PHASES.REPLACING_DEF) txt = `Un joueur doit √™tre remplac√©.`;
      else if (phase === PHASES.REMOVING_ATK) txt = "Choisissez le joueur √† sortir.";
      else if (phase === PHASES.PLACING_REPLACEMENT) txt = "O√π ins√©rer le nouveau joueur ? (+)";
      else if (attackerId === 0) txt = phase === PHASES.CHOOSING_TARGET ? "üéØ CLIQUEZ SUR UNE CARTE ADVERSE !" : `Votre tour ! Cible : ${names[defenderId]}`;
      else txt = `${names[attackerId]} est √† l'offensive...`;
      return <p className="text-[9px] md:text-[10px] font-black uppercase text-slate-500 tracking-widest">{txt}</p>;
    };

    const DropZone = ({ onClick }) => (
      <div onClick={onClick} className="drop-zone group"><Icons.Plus /></div>
    );

    const StatsModal = ({ open, onClose, stats, scores, onReplay, onMenu }) => {
      const [step, setStep] = useState("SUMMARY");
      const [tab, setTab] = useState(0);
      useEffect(() => { if (!open) return; setStep("SUMMARY"); setTab(0); }, [open]);
      if (!open) return null;
      const names = ["VOUS", "IA 1", "IA 2"];
      const safeScores = Array.isArray(scores) ? scores : [0,0,0];
      const rows = (teamId) => Object.values(stats?.[teamId] || {}).sort((a,b) => ((b.atkWins*2 + b.defStops) - (a.atkWins*2 + a.defStops)));
      const pct = (wins, duels) => duels > 0 ? Math.round((wins / duels) * 100) : 0;
      const totals = (teamId) => rows(teamId).reduce((acc, x) => ({ players: acc.players + 1, atkDuels: acc.atkDuels + (x.atkDuels||0), atkWins: acc.atkWins + (x.atkWins||0), defDuels: acc.defDuels + (x.defDuels||0), defStops: acc.defStops + (x.defStops||0) }), { players: 0, atkDuels: 0, atkWins: 0, defDuels: 0, defStops: 0 });
      const teamTotals = [0,1,2].map(tid => totals(tid));
      const max = Math.max(...safeScores);
      const winnerId = (() => { const idxs = safeScores.map((s,i)=>({s,i})).filter(x=>x.s===max).map(x=>x.i); return idxs.length !== 1 ? -1 : idxs[0]; })();
      const winnerLabel = winnerId === -1 ? "√âGALIT√â !" : `üèÜ Vainqueur : ${names[winnerId]}`;
      const teamBadge = (tid) => tid === winnerId ? 'bg-yellow-500 text-black' : 'bg-slate-700 text-slate-100';
      return (
        <div className="fixed inset-0 z-[999] flex items-center justify-center p-2 md:p-4">
          <div onClick={onClose} className="absolute inset-0 bg-black/70 backdrop-blur-sm" />
          <div className="relative w-full max-w-4xl rounded-3xl border border-slate-700 bg-slate-950 shadow-2xl flex flex-col" style={{maxHeight: '95dvh'}}>
            <div className="flex-shrink-0 flex items-center justify-between px-4 md:px-6 py-3 md:py-4 border-b border-slate-800">
              <div>
                <h3 className="font-display text-lg md:text-xl font-black italic uppercase text-white">{step === "SUMMARY" ? "R√©sultats du match" : "Stats du match"}</h3>
              </div>
              <div className="flex gap-2">
                {step === "DETAILS" && <button onClick={() => setStep("SUMMARY")} className="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 text-slate-200 font-black text-xs uppercase">‚Üê R√©sultats</button>}
                <button onClick={onClose} className="px-3 py-2 rounded-xl bg-slate-800 hover:bg-slate-700 text-slate-200 font-black text-xs uppercase">Fermer</button>
              </div>
            </div>
            <div className="flex-1 overflow-y-auto scrollbar-hide">
            {step === "SUMMARY" ? (
              <div className="p-6">
                <div className="flex flex-col md:flex-row md:items-center md:justify-between gap-4 mb-6">
                  <span className={`inline-flex px-4 py-2 rounded-2xl border border-slate-800 bg-slate-900/40 font-black text-sm ${winnerId === -1 ? "text-slate-100" : "text-yellow-400"}`}>{winnerLabel}</span>
                  <div className="flex gap-3 flex-wrap">
                    <button onClick={() => setStep("DETAILS")} className="bg-blue-600 hover:bg-blue-500 text-white px-6 py-2 rounded-xl font-black uppercase text-sm shadow-xl transition-all">Stats joueurs ‚Üí</button>
                    {onReplay && <button onClick={onReplay} className="bg-orange-600 hover:bg-orange-500 text-white px-6 py-2 rounded-xl font-black uppercase text-sm shadow-xl transition-all">Rejouer</button>}
                    {onMenu && <button onClick={onMenu} className="bg-slate-700 hover:bg-slate-600 text-white px-6 py-2 rounded-xl font-black uppercase text-sm transition-all">Menu</button>}
                  </div>
                </div>
                <div className="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                  {[0,1,2].map(tid => (
                    <div key={tid} className="rounded-3xl border border-slate-800 bg-slate-900/30 p-5 shadow-lg">
                      <div className="flex items-center justify-between mb-3">
                        <div className="text-[11px] font-black uppercase tracking-widest text-slate-400">{names[tid]}</div>
                        <div className={`px-3 py-1 rounded-xl font-black text-[11px] ${teamBadge(tid)}`}>{winnerId === -1 ? "‚Äî" : (tid === winnerId ? "WIN" : "LOSE")}</div>
                      </div>
                      <div className="text-5xl font-black text-white">{safeScores[tid] ?? 0}</div>
                    </div>
                  ))}
                </div>
                <div className="rounded-3xl border border-slate-800 bg-slate-900/30 overflow-hidden">
                  <div className="px-5 py-4 border-b border-slate-800"><div className="text-[11px] font-black uppercase tracking-widest text-slate-400">Stats d'√©quipe</div></div>
                  <div className="grid grid-cols-12 gap-0 px-5 py-3 text-[10px] font-black uppercase tracking-widest text-slate-500 border-b border-slate-800">
                    <div className="col-span-3">√âquipe</div><div className="col-span-3 text-center">Joueurs</div>
                    <div className="col-span-3 text-center">OFF</div><div className="col-span-3 text-center">DEF</div>
                  </div>
                  {[0,1,2].map(tid => {
                    const t = teamTotals[tid];
                    return (
                      <div key={tid} className="grid grid-cols-12 px-5 py-4 text-[11px] border-b border-slate-800/60 hover:bg-slate-800/20">
                        <div className="col-span-3 flex items-center gap-2">
                          <span className="font-black text-slate-100">{names[tid]}</span>
                          {winnerId !== -1 && tid === winnerId && <span className="px-2 py-1 rounded-lg bg-yellow-500 text-black font-black text-[10px]">üèÜ</span>}
                        </div>
                        <div className="col-span-3 flex items-center justify-center"><span className="px-3 py-1 rounded-xl bg-slate-800 text-slate-100 font-black text-[11px]">{t.players}</span></div>
                        <div className="col-span-3 flex items-center justify-center gap-2"><span className="font-black text-orange-300">{t.atkWins}/{t.atkDuels}</span><span className="text-slate-500 font-bold">({pct(t.atkWins, t.atkDuels)}%)</span></div>
                        <div className="col-span-3 flex items-center justify-center gap-2"><span className="font-black text-slate-200">{t.defStops}/{t.defDuels}</span><span className="text-slate-500 font-bold">({pct(t.defStops, t.defDuels)}%)</span></div>
                      </div>
                    );
                  })}
                </div>
              </div>
            ) : (
              <>
                <div className="px-6 pt-5">
                  <div className="flex gap-2 bg-slate-900/60 border border-slate-800 rounded-2xl p-1 w-fit">
                    {[0,1,2].map(team => (
                      <button key={team} onClick={() => setTab(team)} className={`px-4 py-2 rounded-xl text-[11px] font-black uppercase transition-all ${tab === team ? 'bg-blue-600 text-white shadow-lg' : 'text-slate-400 hover:text-slate-200'}`}>{names[team]}</button>
                    ))}
                  </div>
                </div>
                <div className="p-6">
                  <div className="rounded-2xl border border-slate-800 bg-slate-900/30 overflow-hidden">
                    <div className="grid grid-cols-12 gap-0 px-4 py-3 text-[10px] font-black uppercase tracking-widest text-slate-500 border-b border-slate-800">
                      <div className="col-span-4">Joueur</div><div className="col-span-2 text-center">Poste</div>
                      <div className="col-span-3 text-center">OFF</div><div className="col-span-3 text-center">DEF</div>
                    </div>
                    {rows(tab).length === 0 ? <div className="p-6 text-slate-400 text-sm">Aucune stat.</div> :
                      rows(tab).map(r => (
                        <div key={r.id} className="grid grid-cols-12 px-4 py-3 text-[11px] border-b border-slate-800/60 hover:bg-slate-800/20">
                          <div className="col-span-4"><div className="font-black text-slate-100 truncate">{(r.name||"???").split(',')[0]}</div><div className="text-[10px] text-slate-500 font-bold">OFF {r.off} ¬∑ DEF {r.def}</div></div>
                          <div className="col-span-2 flex items-center justify-center"><span className="px-2 py-1 rounded-lg bg-yellow-500 text-black font-black text-[10px]">{r.poste}</span></div>
                          <div className="col-span-3 flex items-center justify-center gap-2"><span className="font-black text-orange-300">{r.atkWins}/{r.atkDuels}</span><span className="text-slate-500 font-bold">({pct(r.atkWins, r.atkDuels)}%)</span></div>
                          <div className="col-span-3 flex items-center justify-center gap-2"><span className="font-black text-slate-200">{r.defStops}/{r.defDuels}</span><span className="text-slate-500 font-bold">({pct(r.defStops, r.defDuels)}%)</span></div>
                        </div>
                      ))
                    }
                  </div>
                </div>
              </>
            )}
            </div>
          </div>
        </div>
      );
    };

    const root = ReactDOM.createRoot(document.getElementById('root'));
    root.render(<App />);
  </script>
</body>
</html>